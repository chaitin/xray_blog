<html>
  <head>
    <meta charset="utf-8" />
<meta name="referrer" content="no-referrer">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>lighttpd历史漏洞分析 | xray 技术博客</title>
<link rel="shortcut icon" href="https://blog.xray.cool/favicon.ico?v=1620790414551">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://blog.xray.cool/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="lighttpd历史漏洞分析 | xray 技术博客 - Atom Feed" href="https://blog.xray.cool/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-176727836-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-176727836-2');
</script>


    <meta name="description" content="最近分析了不少IoT设备使用的嵌入式web服务器，发现不少直接使用lighttpd或者魔改lighttpd的例子，对这个开源的httpd产生了些许兴趣，所以来分析一波近两年内lighttpd的历史漏洞，顺便整理一下自己的思路
为什么选择这两..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://blog.xray.cool">
  <img class="avatar" src="https://blog.xray.cool/images/avatar.png?v=1620790414551" alt="">
  </a>
  <h1 class="site-title">
    xray 技术博客
  </h1>
  <p class="site-description">
    
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives/" class="menu">
          归档
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              lighttpd历史漏洞分析
            </h2>
            <div class="post-info">
              <span>
                2020-12-10
              </span>
              <span>
                11 min read
              </span>
              
            </div>
            
              <img class="post-feature-image" src="https://blog.xray.cool/post-images/historical-vulnerability-analysis.jpg" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>最近分析了不少IoT设备使用的嵌入式web服务器，发现不少直接使用lighttpd或者魔改lighttpd的例子，对这个开源的httpd产生了些许兴趣，所以来分析一波近两年内lighttpd的历史漏洞，顺便整理一下自己的思路<br>
为什么选择这两个并不年轻的漏洞呢？这大概是因为嵌入式设备更新缓慢导致漏洞长时间存在，漏洞价值依旧较高。</p>
<h2 id="什么是lighttpd">什么是lighttpd</h2>
<p>Lighttpd（读作lighty）是一款以BSD许可证开源的Web Server，一个专门针对高性能网站，安全、快速、兼容性好并且灵活的Web Server。正因为具有非常低的内存开销、CPU 占用率低、效能好、模块类型丰富等特点，lighttpd成为了使用量最广的嵌入式web Server之一。</p>
<p>Lighttpd目前支持 FastCGI, CGI, Auth, 输出压缩(output compress), URL 重写, Alias 等重要功能。</p>
<p>Lighttpd起源于针对C10K问题的概念验证程序，目前仍然在被维护，已经更新到了1.4.56版本。</p>
<h2 id="cve-2019-11072">CVE-2019-11072</h2>
<p>该漏洞源于1.4.52版本的功能更新，添加了多个httpd启动参数选项，开始支持如下功能</p>
<pre><code class="language-c=">server.http-parseopts = (
        &quot;header-strict&quot;            =&gt; &quot;enable&quot;,
        &quot;host-strict&quot;              =&gt; &quot;enable&quot;,
        &quot;host-normalize&quot;           =&gt; &quot;enable&quot;,
        &quot;url-normalize&quot;            =&gt; &quot;enable&quot;,
        &quot;url-normalize-unreserved&quot; =&gt; &quot;enable&quot;,
        &quot;url-normalize-required&quot;   =&gt; &quot;enable&quot;,
        &quot;url-ctrls-reject&quot;         =&gt; &quot;enable&quot;,
        &quot;url-path-2f-decode&quot;       =&gt; &quot;enable&quot;,
        &quot;url-path-dotseg-remove&quot;   =&gt; &quot;enable&quot;,
        &quot;url-query-20-plus&quot;        =&gt; &quot;enable&quot;
)
</code></pre>
<p>在<code>url-path-2f-decode</code>功能中，<code>%2f</code>将被解码为<code>/</code>，具体的实现位于src/burl.c文件中，如下所示，其中(buffer*)b-&gt;ptr存储的是URL路径，qs变量指的是query string长度，i变量指的是%2F所在下标。</p>
<pre><code class="language-c=">static int burl_normalize_2F_to_slash_fix (buffer *b, int qs, int i)
{
    char * const s = b-&gt;ptr;
    const int blen = (int)buffer_string_length(b);
    const int used = qs &lt; 0 ? blen : qs;
    int j = i;
    for (; i &lt; used; ++i, ++j) {
        s[j] = s[i];
        if (s[i] == '%' &amp;&amp; s[i+1] == '2' &amp;&amp; s[i+2] == 'F') {
            s[j] = '/';
            i+=2;
        }
    }
    if (qs &gt;= 0) {
        memmove(s+j, s+qs, blen - qs);
        j += blen - qs;
    }
    buffer_string_set_length(b, j);
    return qs;
}
</code></pre>
<p>而URL路径整体的标准化实现代码如下</p>
<pre><code class="language-c=">int burl_normalize (buffer *b, buffer *t, int flags)
{
    int qs;

  #if defined(__WIN32) || defined(__CYGWIN__)
    /* Windows and Cygwin treat '\\' as '/' if '\\' is present in path;
     * convert to '/' for consistency before percent-encoding
     * normalization which will convert '\\' to &quot;%5C&quot; in the URL.
     * (Clients still should not be sending '\\' unencoded in requests.) */
    if (flags &amp; HTTP_PARSEOPT_URL_NORMALIZE_PATH_BACKSLASH_TRANS) {
        for (char *p = b-&gt;ptr; *p != '?' &amp;&amp; *p != '\0'; ++p) {
            if (*p == '\\') *p = '/';
        }
    }
  #endif

    qs = (flags &amp; HTTP_PARSEOPT_URL_NORMALIZE_REQUIRED)
      ? burl_normalize_basic_required(b, t)
      : burl_normalize_basic_unreserved(b, t);
    if (-2 == qs) return -2;

    if (flags &amp; HTTP_PARSEOPT_URL_NORMALIZE_CTRLS_REJECT) {
        if (burl_contains_ctrls(b)) return -2;
    }

    if (flags &amp; (HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_DECODE
                |HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_REJECT)) {
        qs = burl_normalize_2F_to_slash(b, qs, flags);
        if (-2 == qs) return -2;
    }

    if (flags &amp; (HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REMOVE
                |HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REJECT)) {
        qs = burl_normalize_path(b, t, qs, flags);
        if (-2 == qs) return -2;
    }

    if (flags &amp; HTTP_PARSEOPT_URL_NORMALIZE_QUERY_20_PLUS) {
        if (qs &gt;= 0) burl_normalize_qs20_to_plus(b, qs);
    }

    return qs;
}
</code></pre>
<p>看上去没啥问题，但其实暗藏玄机！<code>burl_normalize_2F_to_slash_fix</code>这句<code>memmove(s+j, s+qs, blen - qs)</code>中的<code>qs</code>在解码后并未缩小，后续<code>burl_normalize_path</code>再次使用qs时，在裁剪query string时有可能导致负溢，后续裁剪URL代码如下</p>
<pre><code class="language-c=">static int burl_normalize_path (buffer *b, buffer *t, int qs, int flags)
{
    const unsigned char * const s = (unsigned char *)b-&gt;ptr;
    const int used = (int)buffer_string_length(b);
    int path_simplify = 0;
    for (int i = 0, len = qs &lt; 0 ? used : qs; i &lt; len; ++i) {
        if (s[i] == '.' &amp;&amp; (s[i+1] != '.' || ++i)
            &amp;&amp; (s[i+1] == '/' || s[i+1] == '?' || s[i+1] == '\0')) {
            path_simplify = 1;
            break;
        }
        while (i &lt; len &amp;&amp; s[i] != '/') ++i;
        if (s[i] == '/' &amp;&amp; s[i+1] == '/') { /*(s[len] != '/')*/
            path_simplify = 1;
            break;
        }
    }

    if (path_simplify) {
        if (flags &amp; HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REJECT) return -2;
        if (qs &gt;= 0) {
            buffer_copy_string_len(t, b-&gt;ptr+qs, used - qs);
            buffer_string_set_length(b, qs);
        }

        buffer_path_simplify(b, b);

        if (qs &gt;= 0) {
            qs = (int)buffer_string_length(b);
            buffer_append_string_len(b, CONST_BUF_LEN(t));
        }
    }

    return qs;
}
</code></pre>
<p>注意这里的<code>used - qs</code>，后文会提到</p>
<p>现在我们开启<code>url-path-2f-decode</code>功能，把gdb挂到lighttpd测试一下，lighttpd在<a href="https://redmine.lighttpd.net/attachments/download/1939/lighttpd.conf">配置文件</a>中指定开启<code>url-path-2f-decode</code>功能。</p>
<p>发送畸形请求（query string为<code>%2F?</code>）<br>
<img src="https://i.imgur.com/2ciwSGI.png" alt="" loading="lazy"></p>
<p>果然crash了<br>
<img src="https://i.imgur.com/e8Lzf4e.png" alt="" loading="lazy"></p>
<p>再次reproduce，并在<code>burl_normalize_2F_to_slash_fix</code>处步入调试。<br>
进入循环前query string长度为4， <code>%2F</code>下标为1；<br>
<img src="https://i.imgur.com/fHwS8Fs.png" alt="" loading="lazy"></p>
<p>循环过后成功将<code>%2F</code>解码，并拷贝余下的query string<br>
<img src="https://i.imgur.com/T4KbMk2.png" alt="" loading="lazy"></p>
<p>随后进入<code>burl_normalize_path</code>，到<code>buffer_copy_string_len(t, b-&gt;ptr+qs, used - qs);</code>这一步，有意思的事情发生了<br>
<img src="https://i.imgur.com/1DS4kIJ.png" alt="" loading="lazy"></p>
<p>拷贝长度发生了负溢，used小于qs。至于原因，得从前文给出的<code>burl_normalize_path</code>说起，used取解码后query string长度，而qs却并未更新，依旧是解码前的长度，从而导致used小于qs，引发负溢。以下是崩溃的backtrace<br>
<img src="https://i.imgur.com/QlcO9pk.png" alt="" loading="lazy"></p>
<p>至于这个漏洞的后续利用，笔者并没有进行后续的探索，从backtrace来看，是在<code>malloc(-1)</code>返回0后触发断言导致崩溃，除非能够有其他的堆溢出覆写top chunk size，走house of force这种古董级ptmalloc利用方法，不然是不能RCE只能DoS的。</p>
<h2 id="cve-2018-19052">CVE-2018-19052</h2>
<p>该漏洞应该算是 nginx alias 配置不当导致目录穿越漏洞的复刻版，影响范围为1.4.50之前全部版本。</p>
<p>这里我们直接看下1.4.49和1.4.50版本的diff</p>
<pre><code>@@ -161,26 +161,41 @@
	if (buffer_is_empty(con-&gt;physical.path)) return HANDLER_GO_ON;
	mod_alias_patch_connection(srv, con, p);
	/* not to include the tailing slash */
	basedir_len = buffer_string_length(con-&gt;physical.basedir);
	if ('/' == con-&gt;physical.basedir-&gt;ptr[basedir_len-1]) --basedir_len;
	uri_len = buffer_string_length(con-&gt;physical.path) - basedir_len;
	uri_ptr = con-&gt;physical.path-&gt;ptr + basedir_len;
	for (k = 0; k &lt; p-&gt;conf.alias-&gt;used; k++) {
		data_string *ds = (data_string *)p-&gt;conf.alias-&gt;data[k];
		int alias_len = buffer_string_length(ds-&gt;key);
		if (alias_len &gt; uri_len) continue;
		if (buffer_is_empty(ds-&gt;key)) continue;
		if (0 == (con-&gt;conf.force_lowercase_filenames ?
					strncasecmp(uri_ptr, ds-&gt;key-&gt;ptr, alias_len) :
					strncmp(uri_ptr, ds-&gt;key-&gt;ptr, alias_len))) {
			/* matched */

+			/* check for path traversal in url-path following alias if key
+			 * does not end in slash, but replacement value ends in slash */
+			if (uri_ptr[alias_len] == '.') {
+				char *s = uri_ptr + alias_len + 1;
+				if (*s == '.') ++s;
+				if (*s == '/' || *s == '\0') {
+					size_t vlen = buffer_string_length(ds-&gt;value);
+					if (0 != alias_len &amp;&amp; ds-&gt;key-&gt;ptr[alias_len-1] != '/'
+					    &amp;&amp; 0 != vlen &amp;&amp; ds-&gt;value-&gt;ptr[vlen-1] == '/') {
+						con-&gt;http_status = 403;
+						return HANDLER_FINISHED;
+					}
+				}
+			}

			buffer_copy_buffer(con-&gt;physical.basedir, ds-&gt;value);
			buffer_copy_buffer(srv-&gt;tmp_buf, ds-&gt;value);
			buffer_append_string(srv-&gt;tmp_buf, uri_ptr + alias_len);
</code></pre>
<p>很明显，加了个结尾是否为<code>/</code>的检测</p>
<p>不多比比，直接上payload测一波，先写个配置文件</p>
<pre><code class="language-python=">#debug.log-request-handling = &quot;enable&quot;
#debug.log-request-header = &quot;enable&quot;
#debug.log-response-header = &quot;enable&quot;
#debug.log-condition-handling = &quot;enable&quot;
server.document-root         = &quot;/tmp/lighttpd2/&quot;

## 64 Mbyte ... nice limit
server.max-request-size = 65000

## bind to port (default: 80)
server.port                 = 8090

## bind to localhost (default: all interfaces)
server.bind                = &quot;localhost&quot;
server.errorlog            = &quot;/dev/null&quot;
server.breakagelog         = &quot;/dev/null&quot;
server.name                = &quot;www.example.org&quot;
server.tag                 = &quot;Apache 1.3.29&quot;

server.dir-listing          = &quot;enable&quot;

server.indexfiles = (
	&quot;index.html&quot;,
)

server.modules = ( &quot;mod_alias&quot; )
alias.url = ( &quot;/docs&quot; =&gt; &quot;/tmp/lighttpd2/docs/&quot; )

server.http-parseopts = (
#        &quot;header-strict&quot;            =&gt; &quot;enable&quot;,
#        &quot;host-strict&quot;              =&gt; &quot;enable&quot;,
#        &quot;host-normalize&quot;           =&gt; &quot;enable&quot;,
#        &quot;url-normalize&quot;            =&gt; &quot;enable&quot;,
#        &quot;url-normalize-unreserved&quot; =&gt; &quot;enable&quot;,
#        &quot;url-normalize-required&quot;   =&gt; &quot;enable&quot;,
#        &quot;url-ctrls-reject&quot;         =&gt; &quot;enable&quot;,
#        &quot;url-path-2f-decode&quot;       =&gt; &quot;enable&quot;
#        &quot;url-path-dotseg-remove&quot;   =&gt; &quot;enable&quot;,
#        &quot;url-query-20-plus&quot;        =&gt; &quot;enable&quot;
      )

ssi.extension = (
	&quot;.shtml&quot;,
)

accesslog.filename = &quot;/dev/null&quot;

mimetype.assign = (
	&quot;.png&quot;  =&gt; &quot;image/png&quot;,
	&quot;.jpg&quot;  =&gt; &quot;image/jpeg&quot;,
	&quot;.jpeg&quot; =&gt; &quot;image/jpeg&quot;,
	&quot;.gif&quot;  =&gt; &quot;image/gif&quot;,
	&quot;.html&quot; =&gt; &quot;text/html&quot;,
	&quot;.htm&quot;  =&gt; &quot;text/html&quot;,
	&quot;.pdf&quot;  =&gt; &quot;application/pdf&quot;,
	&quot;.swf&quot;  =&gt; &quot;application/x-shockwave-flash&quot;,
	&quot;.spl&quot;  =&gt; &quot;application/futuresplash&quot;,
	&quot;.txt&quot;  =&gt; &quot;text/plain&quot;,
	&quot;.tar.gz&quot; =&gt;   &quot;application/x-tgz&quot;,
	&quot;.tgz&quot;  =&gt; &quot;application/x-tgz&quot;,
	&quot;.gz&quot;   =&gt; &quot;application/x-gzip&quot;,
	&quot;.c&quot;    =&gt; &quot;text/plain&quot;,
	&quot;.conf&quot; =&gt; &quot;text/plain&quot;,
)

setenv.add-environment = (
	&quot;TRAC_ENV&quot; =&gt; &quot;tracenv&quot;,
	&quot;SETENV&quot; =&gt; &quot;setenv&quot;,
)
setenv.set-environment = (
	&quot;NEWENV&quot; =&gt; &quot;newenv&quot;,
)
setenv.add-request-header = (
	&quot;FOO&quot; =&gt; &quot;foo&quot;,
)
setenv.set-request-header = (
	&quot;FOO2&quot; =&gt; &quot;foo2&quot;,
)
setenv.add-response-header = (
	&quot;BAR&quot; =&gt; &quot;foo&quot;,
)
setenv.set-response-header = (
	&quot;BAR2&quot; =&gt; &quot;bar2&quot;,
)
</code></pre>
<p>这里的<code>alias.url = ( &quot;/docs&quot; =&gt; &quot;/tmp/lighttpd2/docs/&quot; )</code>就是漏洞所在，没有用<code>/</code>去结束这个目录路径，为了展示漏洞效果，我在<code>/tmp/lighttpd2</code>目录下放了个<code>.htpasswd</code>文件（嵌入式web server常见操作——把明文密码放在主目录下等着被人信息泄露 <em>此处狗头</em>）</p>
<p><img src="https://i.imgur.com/ZXLLhdX.png" alt="" loading="lazy"><br>
<img src="https://i.imgur.com/P21CTPP.png" alt="" loading="lazy"></p>
<h2 id="结语">结语</h2>
<p>嵌入式web服务器和主流web服务器的安全性还是有相当差距的，但因为寄主是物联网设备，寄主对安全保护能力的要求并不高，导致嵌入式web服务器常常成为攻击的切入点。也许“一杯茶，一支烟，一个破站日一天”并不是因为安全，而是因为你没有选对切入点，或许从目标站点相关的物联网设备下手，能取得意想不到的收获。</p>
<p>本文写得仓促，见谅见谅。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFlighttpd">什么是lighttpd</a></li>
<li><a href="#cve-2019-11072">CVE-2019-11072</a></li>
<li><a href="#cve-2018-19052">CVE-2018-19052</a></li>
<li><a href="#%E7%BB%93%E8%AF%AD">结语</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://blog.xray.cool/post/12cases-about-xss-part2/">
              <h3 class="post-title">
                十二个案例重新认识 XSS (下)
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  
  <a class="rss" href="https://blog.xray.cool/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
